yarn run v1.22.18
$ xnft dev
ðŸ‘€ watching /Users/nprince/source/helium/packages/xnft-hotspot
falling back to latest renderer
listening on port 9933
Building...
ðŸš¨ Build failed.

@parcel/core: Failed to resolve 'assert' from 
'/Users/nprince/source/anchor/ts/packages/anchor/dist/browser/index.js'

  /Users/nprince/source/anchor/ts/packages/anchor/dist/browser/index.js:3:7
    2 | //# sourceMappingURL=index.js.map
  > 3 | 
  >   | ^
[Error: ENOENT: no such file or directory, open '/Users/nprince/source/helium/packages/anchor/ts/packages/src/utils/bytes/hex.ts'] {
  errno: -2,
  code: 'ENOENT',
  syscall: 'open',
  path: '/Users/nprince/source/helium/packages/anchor/ts/packages/src/utils/bytes/hex.ts'
}
build changed
build error {"type":"buildFailure","diagnostics":[{"message":"Failed to resolve 'assert' from '/Users/nprince/source/anchor/ts/packages/anchor/dist/browser/index.js'","origin":"@parcel/core","codeFrames":[{"filePath":"/Users/nprince/source/anchor/ts/packages/anchor/dist/browser/index.js","code":"import{Buffer as t}from\"buffer\";import{PublicKey as e,Transaction as n,TransactionInstruction as r,SendTransactionError as o,NONCE_ACCOUNT_LENGTH as i,SystemProgram as s,SYSVAR_RENT_PUBKEY as a}from\"@solana/web3.js\";import*as c from\"@solana/web3.js\";export{c as web3};import u from\"bn.js\";export{default as BN}from\"bn.js\";import d from\"bs58\";import*as l from\"base64-js\";import h from\"camelcase\";import{sha256 as p}from\"js-sha256\";import*as f from\"@project-serum/borsh\";import{inflate as m}from\"pako\";import y from\"eventemitter3\";import*as g from\"assert\";var w=Object.freeze({__proto__:null,encode:function(t){return t.reduce(((t,e)=>t+e.toString(16).padStart(2,\"0\")),\"0x\")},decode:function(e){0===e.indexOf(\"0x\")&&(e=e.substr(2)),e.length%2==1&&(e=\"0\"+e);let n=e.match(/.{2}/g);return null===n?t.from([]):t.from(n.map((t=>parseInt(t,16))))}});function v(t){return new TextDecoder(\"utf-8\").decode(t)}function b(t){return(new TextEncoder).encode(t)}var A=Object.freeze({__proto__:null,decode:v,encode:b});function _(t){return d.encode(t)}var S=Object.freeze({__proto__:null,encode:_,decode:function(t){return d.decode(t)}});function E(e){return t.from(l.toByteArray(e))}var I=Object.freeze({__proto__:null,encode:function(t){return l.fromByteArray(t)},decode:E}),k=Object.freeze({__proto__:null,hex:w,utf8:A,bs58:S,base64:I});function x(t){const e=new Map;return t.errors&&t.errors.forEach((t=>{var n;let r=null!==(n=t.msg)&&void 0!==n?n:t.name;e.set(t.code,r)})),e}function M(t,...e){if(t.args.length!=e.length)throw new Error(\"Invalid argument length\");const n={};let r=0;return t.args.forEach((t=>{n[t.name]=e[r],r+=1})),n}function P(t,e={}){t.forEach((t=>{if(\"accounts\"in t)P(t.accounts,e[t.name]);else if(void 0===e[t.name])throw new Error(`Invalid arguments: ${t.name} not provided.`)}))}function L(t){return t instanceof e?t:new e(t)}class T extends TypeError{constructor(t,e){let n;const{message:r,...o}=t,{path:i}=t;super(0===i.length?r:\"At path: \"+i.join(\".\")+\" -- \"+r),this.value=void 0,this.key=void 0,this.type=void 0,this.refinement=void 0,this.path=void 0,this.branch=void 0,this.failures=void 0,Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>{var r;return null!=(r=n)?r:n=[t,...e()]}}}function C(t){return\"object\"==typeof t&&null!=t}function z(t){return\"string\"==typeof t?JSON.stringify(t):\"\"+t}function B(t,e,n,r){if(!0===t)return;!1===t?t={}:\"string\"==typeof t&&(t={message:t});const{path:o,branch:i}=e,{type:s}=n,{refinement:a,message:c=\"Expected a value of type `\"+s+\"`\"+(a?\" with refinement `\"+a+\"`\":\"\")+\", but received: `\"+z(r)+\"`\"}=t;return{value:r,type:s,refinement:a,key:o[o.length-1],path:o,branch:i,...t,message:c}}function*O(t,e,n,r){var o;C(o=t)&&\"function\"==typeof o[Symbol.iterator]||(t=[t]);for(const o of t){const t=B(o,e,n,r);t&&(yield t)}}function*D(t,e,n){void 0===n&&(n={});const{path:r=[],branch:o=[t],coerce:i=!1,mask:s=!1}=n,a={path:r,branch:o};if(i&&(t=e.coercer(t,a),s&&\"type\"!==e.type&&C(e.schema)&&C(t)&&!Array.isArray(t)))for(const n in t)void 0===e.schema[n]&&delete t[n];let c=!0;for(const n of e.validator(t,a))c=!1,yield[n,void 0];for(let[n,u,d]of e.entries(t,a)){const e=D(u,d,{path:void 0===n?r:[...r,n],branch:void 0===n?o:[...o,u],coerce:i,mask:s});for(const r of e)r[0]?(c=!1,yield[r[0],void 0]):i&&(u=r[1],void 0===n?t=u:t instanceof Map?t.set(n,u):t instanceof Set?t.add(u):C(t)&&(t[n]=u))}if(c)for(const n of e.refiner(t,a))c=!1,yield[n,void 0];c&&(yield[void 0,t])}class N{constructor(t){this.TYPE=void 0,this.type=void 0,this.schema=void 0,this.coercer=void 0,this.validator=void 0,this.refiner=void 0,this.entries=void 0;const{type:e,schema:n,validator:r,refiner:o,coercer:i=(t=>t),entries:s=function*(){}}=t;this.type=e,this.schema=n,this.entries=s,this.coercer=i,this.validator=r?(t,e)=>O(r(t,e),e,this,t):()=>[],this.refiner=o?(t,e)=>O(o(t,e),e,this,t):()=>[]}assert(t){return function(t,e){const n=U(t,e);if(n[0])throw n[0]}(t,this)}create(t){return R(t,this)}is(t){return V(t,this)}mask(t){return function(t,e){const n=U(t,e,{coerce:!0,mask:!0});if(n[0])throw n[0];return n[1]}(t,this)}validate(t,e){return void 0===e&&(e={}),U(t,this,e)}}function R(t,e){const n=U(t,e,{coerce:!0});if(n[0])throw n[0];return n[1]}function V(t,e){return!U(t,e)[0]}function U(t,e,n){void 0===n&&(n={});const r=D(t,e,n),o=function(t){const{done:e,value:n}=t.next();return e?void 0:n}(r);if(o[0]){return[new T(o[0],(function*(){for(const t of r)t[0]&&(yield t[0])})),void 0]}return[void 0,o[1]]}function j(t,e){return new N({type:t,schema:null,validator:e})}function $(t){return new N({type:\"array\",schema:t,*entries(e){if(t&&Array.isArray(e))for(const[n,r]of e.entries())yield[n,r,t]},coercer:t=>Array.isArray(t)?t.slice():t,validator:t=>Array.isArray(t)||\"Expected an array value, but received: \"+z(t)})}function K(t){const e=z(t),n=typeof t;return new N({type:\"literal\",schema:\"string\"===n||\"number\"===n||\"boolean\"===n?t:null,validator:n=>n===t||\"Expected the literal `\"+e+\"`, but received: \"+z(n)})}function q(t){return new N({...t,validator:(e,n)=>null===e||t.validator(e,n),refiner:(e,n)=>null===e||t.refiner(e,n)})}function F(){return j(\"number\",(t=>\"number\"==typeof t&&!isNaN(t)||\"Expected a number, but received: \"+z(t)))}function W(t){return new N({...t,validator:(e,n)=>void 0===e||t.validator(e,n),refiner:(e,n)=>void 0===e||t.refiner(e,n)})}function G(){return j(\"string\",(t=>\"string\"==typeof t||\"Expected a string, but received: \"+z(t)))}function H(t){const e=Object.keys(t);return new N({type:\"type\",schema:t,*entries(n){if(C(n))for(const r of e)yield[r,n[r],t[r]]},validator:t=>C(t)||\"Expected an object, but received: \"+z(t)})}function J(t){const e=t.map((t=>t.type)).join(\" | \");return new N({type:\"union\",schema:null,coercer:(e,n)=>(t.find((t=>{const[n]=t.validate(e,{coerce:!0});return!n}))||Z()).coercer(e,n),validator(n,r){const o=[];for(const e of t){const[...t]=D(n,e,r),[i]=t;if(!i[0])return[];for(const[e]of t)e&&o.push(e)}return[\"Expected the value to satisfy a union of `\"+e+\"`, but received: \"+z(n),...o]}})}function Z(){return j(\"unknown\",(()=>!0))}async function X(t,e,n){if(e.length<=99)return await Q(t,e,n);{const r=function(t,e){return Array.apply(0,new Array(Math.ceil(t.length/e))).map(((n,r)=>t.slice(r*e,(r+1)*e)))}(e,99);return(await Promise.all(r.map((e=>Q(t,e,n))))).flat()}}async function Q(t,e,n){const r=null!=n?n:t.commitment;return(await t.getMultipleAccountsInfo(e,r)).map(((t,n)=>null===t?null:{publicKey:e[n],account:t}))}async function Y(t,e,n,r,i){n&&n.length>0&&e.sign(...n);const s=e._compile(),a=s.serialize(),c=e._serialize(a).toString(\"base64\"),u={encoding:\"base64\",commitment:null!=r?r:t.commitment};if(i){const t=(Array.isArray(i)?i:s.nonProgramIds()).map((t=>t.toBase58()));u.accounts={encoding:\"base64\",addresses:t}}n&&(u.sigVerify=!0);const d=[c,u],l=R(await t._rpcRequest(\"simulateTransaction\",d),rt);if(\"error\"in l){let t;if(\"data\"in l.error&&(t=l.error.data.logs,t&&Array.isArray(t))){const e=\"\\n    \",n=e+t.join(e);console.error(l.error.message,n)}throw new o(\"failed to simulate transaction: \"+l.error.message,t)}return l.result}function tt(t){return function(t,e,n){return new N({...t,coercer:(r,o)=>V(r,e)?t.coercer(n(r,o),o):t.coercer(r,o)})}(nt(t),et,(e=>\"error\"in e?e:{...e,result:R(e.result,t)}))}const et=nt(Z());function nt(t){return J([H({jsonrpc:K(\"2.0\"),id:G(),result:t}),H({jsonrpc:K(\"2.0\"),id:G(),error:H({code:Z(),message:G(),data:W(j(\"any\",(()=>!0)))})})])}const rt=(ot=H({err:q(J([H({}),G()])),logs:q($(G())),accounts:W(q($(q(H({executable:j(\"boolean\",(t=>\"boolean\"==typeof t)),owner:G(),lamports:F(),data:$(G()),rentEpoch:W(F())}))))),unitsConsumed:W(F())}),tt(H({context:H({slot:F()}),value:ot})));var ot,it=Object.freeze({__proto__:null,invoke:async function(t,e,o,i){t=L(t),i||(i=lt());const s=new n;if(s.add(new r({programId:t,keys:null!=e?e:[],data:o})),void 0===i.sendAndConfirm)throw new Error(\"This function requires 'Provider.sendAndConfirm' to be implemented.\");return await i.sendAndConfirm(s,[])},getMultipleAccounts:X,simulateTransaction:Y});class st{constructor(t,e,n){this.connection=t,this.wallet=e,this.opts=n,this.publicKey=e.publicKey}static defaultOptions(){return{preflightCommitment:\"processed\",commitment:\"processed\"}}static local(t,e){throw new Error(\"Provider local is not available on browser.\")}static env(){throw new Error(\"Provider env is not available on browser.\")}async sendAndConfirm(t,e,n){var r;void 0===n&&(n=this.opts),t.feePayer=this.wallet.publicKey,t.recentBlockhash=(await this.connection.getRecentBlockhash(n.preflightCommitment)).blockhash,t=await this.wallet.signTransaction(t),(null!=e?e:[]).forEach((e=>{t.partialSign(e)}));const i=t.serialize();try{return await ct(this.connection,i,n)}catch(e){if(e instanceof ut){const n=await this.connection.getTransaction(_(t.signature),{commitment:\"confirmed\"});if(n){const t=null===(r=n.meta)||void 0===r?void 0:r.logMessages;throw t?new o(e.message,t):e}throw e}throw e}}async sendAll(t,e){void 0===e&&(e=this.opts);const n=await this.connection.getRecentBlockhash(e.preflightCommitment);let r=t.map((t=>{var e;let r=t.tx,o=null!==(e=t.signers)&&void 0!==e?e:[];return r.feePayer=this.wallet.publicKey,r.recentBlockhash=n.blockhash,o.forEach((t=>{r.partialSign(t)})),r}));const o=await this.wallet.signAllTransactions(r),i=[];for(let t=0;t<r.length;t+=1){const n=o[t].serialize();i.push(await ct(this.connection,n,e))}return i}async simulate(t,e,n,r){t.feePayer=this.wallet.publicKey,t.recentBlockhash=(await this.connection.getLatestBlockhash(null!=n?n:this.connection.commitment)).blockhash,t=await this.wallet.signTransaction(t);const o=await Y(this.connection,t,e,n,r);if(o.value.err)throw new at(o.value);return o.value}}class at extends Error{constructor(t,e){super(e),this.simulationResponse=t}}async function ct(t,e,n){const r=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment},o=await t.sendRawTransaction(e,r),i=(await t.confirmTransaction(o,n&&n.commitment)).value;if(i.err)throw new ut(`Raw transaction ${o} failed (${JSON.stringify(i)})`);return o}class ut extends Error{constructor(t){super(t)}}function dt(t){ht=t}function lt(){return null===ht?st.local():ht}let ht=null;const pt=new Set([\"anchor-deprecated-state\",\"debug-logs\"]),ft=new Map;function mt(t){return void 0!==ft.get(t)}var yt=Object.freeze({__proto__:null,set:function(t){if(!pt.has(t))throw new Error(\"Invalid feature\");ft.set(t,!0)},isSet:mt});class gt extends Error{constructor(t){super(t),this.name=\"IdlError\"}}class wt{constructor(t){this.stack=t}static parse(t){var n;const r=/^Program (\\w*) invoke/,o=/^Program \\w* success/,i=[];for(let s=0;s<t.length;s++){if(o.exec(t[s])){i.pop();continue}const a=null===(n=r.exec(t[s]))||void 0===n?void 0:n[1];a&&i.push(new e(a))}return new wt(i)}}class vt extends Error{constructor(t,e,n,r,o,i){super(n.join(\"\\n\").replace(\"Program log: \",\"\")),this.errorLogs=n,this.logs=r,this.error={errorCode:t,errorMessage:e,comparedValues:i,origin:o},this._programErrorStack=wt.parse(r)}static parse(t){if(!t)return null;const n=t.findIndex((t=>t.startsWith(\"Program log: AnchorError\")));if(-1===n)return null;const r=t[n],o=[r];let i;if(n+1<t.length)if(\"Program log: Left:\"===t[n+1]){const r=/^Program log: (.*)$/,s=r.exec(t[n+2])[1],a=r.exec(t[n+4])[1];i=[new e(s),new e(a)],o.push(...t.slice(n+1,n+5))}else if(t[n+1].startsWith(\"Program log: Left:\")){const e=/^Program log: (Left|Right): (.*)$/,r=e.exec(t[n+1])[2],s=e.exec(t[n+2])[2];o.push(...t.slice(n+1,n+3)),i=[r,s]}const s=/^Program log: AnchorError occurred\\. Error Code: (.*)\\. Error Number: (\\d*)\\. Error Message: (.*)\\./.exec(r),a=/^Program log: AnchorError thrown in (.*):(\\d*)\\. Error Code: (.*)\\. Error Number: (\\d*)\\. Error Message: (.*)\\./.exec(r),c=/^Program log: AnchorError caused by account: (.*)\\. Error Code: (.*)\\. Error Number: (\\d*)\\. Error Message: (.*)\\./.exec(r);if(s){const[e,n,r]=s.slice(1,4),a={code:e,number:parseInt(n)};return new vt(a,r,o,t,void 0,i)}if(a){const[e,n,r,s,c]=a.slice(1,6),u={code:r,number:parseInt(s)},d={file:e,line:parseInt(n)};return new vt(u,c,o,t,d,i)}if(c){const[e,n,r,s]=c.slice(1,5),a=e,u={code:n,number:parseInt(r)};return new vt(u,s,o,t,a,i)}return null}get program(){return this._programErrorStack.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){return this._programErrorStack.stack}toString(){return this.message}}class bt extends Error{constructor(t,e,n){super(),this.code=t,this.msg=e,this.logs=n,n&&(this._programErrorStack=wt.parse(n))}static parse(t,e){const n=t.toString();let r,o;if(n.includes(\"custom program error:\")){let t=n.split(\"custom program error: \");if(2!==t.length)return null;r=t[1]}else{const t=n.match(/\"Custom\":([0-9]+)}/g);if(!t||t.length>1)return null;r=t[0].match(/([0-9]+)/g)[0]}try{o=parseInt(r)}catch(t){return null}let i=e.get(o);return void 0!==i?new bt(o,i,t.logs):(i=St.get(o),void 0!==i?new bt(o,i,t.logs):null)}get program(){var t;return null===(t=this._programErrorStack)||void 0===t?void 0:t.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){var t;return null===(t=this._programErrorStack)||void 0===t?void 0:t.stack}toString(){return this.msg}}function At(t,e){mt(\"debug-logs\")&&console.log(\"Translating error:\",t);const n=vt.parse(t.logs);if(n)return n;const r=bt.parse(t,e);if(r)return r;if(t.logs){const e={get:function(e,n){return\"programErrorStack\"===n?e.programErrorStack.stack:\"program\"===n?e.programErrorStack.stack[t.programErrorStack.stack.length-1]:Reflect.get(...arguments)}};return t.programErrorStack=wt.parse(t.logs),new Proxy(t,e)}return t}const _t={InstructionMissing:100,InstructionFallbackNotFound:101,InstructionDidNotDeserialize:102,InstructionDidNotSerialize:103,IdlInstructionStub:1e3,IdlInstructionInvalidProgram:1001,ConstraintMut:2e3,ConstraintHasOne:2001,ConstraintSigner:2002,ConstraintRaw:2003,ConstraintOwner:2004,ConstraintRentExempt:2005,ConstraintSeeds:2006,ConstraintExecutable:2007,ConstraintState:2008,ConstraintAssociated:2009,ConstraintAssociatedInit:2010,ConstraintClose:2011,ConstraintAddress:2012,ConstraintZero:2013,ConstraintTokenMint:2014,ConstraintTokenOwner:2015,ConstraintMintMintAuthority:2016,ConstraintMintFreezeAuthority:2017,ConstraintMintDecimals:2018,ConstraintSpace:2019,RequireViolated:2500,RequireEqViolated:2501,RequireKeysEqViolated:2502,RequireNeqViolated:2503,RequireKeysNeqViolated:2504,RequireGtViolated:2505,RequireGteViolated:2506,AccountDiscriminatorAlreadySet:3e3,AccountDiscriminatorNotFound:3001,AccountDiscriminatorMismatch:3002,AccountDidNotDeserialize:3003,AccountDidNotSerialize:3004,AccountNotEnoughKeys:3005,AccountNotMutable:3006,AccountOwnedByWrongProgram:3007,InvalidProgramId:3008,InvalidProgramExecutable:3009,AccountNotSigner:3010,AccountNotSystemOwned:3011,AccountNotInitialized:3012,AccountNotProgramData:3013,AccountNotAssociatedTokenAccount:3014,AccountSysvarMismatch:3015,AccountReallocExceedsLimit:3016,AccountDuplicateReallocs:3017,StateInvalidAddress:4e3,DeclaredProgramIdMismatch:4100,Deprecated:5e3},St=new Map([[_t.InstructionMissing,\"8 byte instruction identifier not provided\"],[_t.InstructionFallbackNotFound,\"Fallback functions are not supported\"],[_t.InstructionDidNotDeserialize,\"The program could not deserialize the given instruction\"],[_t.InstructionDidNotSerialize,\"The program could not serialize the given instruction\"],[_t.IdlInstructionStub,\"The program was compiled without idl instructions\"],[_t.IdlInstructionInvalidProgram,\"The transaction was given an invalid program for the IDL instruction\"],[_t.ConstraintMut,\"A mut constraint was violated\"],[_t.ConstraintHasOne,\"A has_one constraint was violated\"],[_t.ConstraintSigner,\"A signer constraint was violated\"],[_t.ConstraintRaw,\"A raw constraint was violated\"],[_t.ConstraintOwner,\"An owner constraint was violated\"],[_t.ConstraintRentExempt,\"A rent exemption constraint was violated\"],[_t.ConstraintSeeds,\"A seeds constraint was violated\"],[_t.ConstraintExecutable,\"An executable constraint was violated\"],[_t.ConstraintState,\"A state constraint was violated\"],[_t.ConstraintAssociated,\"An associated constraint was violated\"],[_t.ConstraintAssociatedInit,\"An associated init constraint was violated\"],[_t.ConstraintClose,\"A close constraint was violated\"],[_t.ConstraintAddress,\"An address constraint was violated\"],[_t.ConstraintZero,\"Expected zero account discriminant\"],[_t.ConstraintTokenMint,\"A token mint constraint was violated\"],[_t.ConstraintTokenOwner,\"A token owner constraint was violated\"],[_t.ConstraintMintMintAuthority,\"A mint mint authority constraint was violated\"],[_t.ConstraintMintFreezeAuthority,\"A mint freeze authority constraint was violated\"],[_t.ConstraintMintDecimals,\"A mint decimals constraint was violated\"],[_t.ConstraintSpace,\"A space constraint was violated\"],[_t.RequireViolated,\"A require expression was violated\"],[_t.RequireEqViolated,\"A require_eq expression was violated\"],[_t.RequireKeysEqViolated,\"A require_keys_eq expression was violated\"],[_t.RequireNeqViolated,\"A require_neq expression was violated\"],[_t.RequireKeysNeqViolated,\"A require_keys_neq expression was violated\"],[_t.RequireGtViolated,\"A require_gt expression was violated\"],[_t.RequireGteViolated,\"A require_gte expression was violated\"],[_t.AccountDiscriminatorAlreadySet,\"The account discriminator was already set on this account\"],[_t.AccountDiscriminatorNotFound,\"No 8 byte discriminator was found on the account\"],[_t.AccountDiscriminatorMismatch,\"8 byte discriminator did not match what was expected\"],[_t.AccountDidNotDeserialize,\"Failed to deserialize the account\"],[_t.AccountDidNotSerialize,\"Failed to serialize the account\"],[_t.AccountNotEnoughKeys,\"Not enough account keys given to the instruction\"],[_t.AccountNotMutable,\"The given account is not mutable\"],[_t.AccountOwnedByWrongProgram,\"The given account is owned by a different program than expected\"],[_t.InvalidProgramId,\"Program ID was not as expected\"],[_t.InvalidProgramExecutable,\"Program account is not executable\"],[_t.AccountNotSigner,\"The given account did not sign\"],[_t.AccountNotSystemOwned,\"The given account is not owned by the system program\"],[_t.AccountNotInitialized,\"The program expected this account to be already initialized\"],[_t.AccountNotProgramData,\"The given account is not a program data account\"],[_t.AccountNotAssociatedTokenAccount,\"The given account is not the associated token account\"],[_t.AccountSysvarMismatch,\"The given public key does not match the required sysvar\"],[_t.AccountReallocExceedsLimit,\"The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit\"],[_t.AccountDuplicateReallocs,\"The account was duplicated for more than one reallocation\"],[_t.StateInvalidAddress,\"The given state account does not have the correct address\"],[_t.DeclaredProgramIdMismatch,\"The declared program id does not match the actual program id\"],[_t.Deprecated,\"The API being used is deprecated and should no longer be used\"]]);var Et=function(){return Et=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var o in e=arguments[n])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t},Et.apply(this,arguments)},It=function(){return It=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var o in e=arguments[n])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t},It.apply(this,arguments)};function kt(t){return t.toLowerCase()}var xt=[/([a-z0-9])([A-Z])/g,/([A-Z])([A-Z][a-z])/g],Mt=/[^A-Z0-9]+/gi;function Pt(t,e,n){return e instanceof RegExp?t.replace(e,n):e.reduce((function(t,e){return t.replace(e,n)}),t)}function Lt(t,e){return void 0===e&&(e={}),function(t,e){void 0===e&&(e={});for(var n=e.splitRegexp,r=void 0===n?xt:n,o=e.stripRegexp,i=void 0===o?Mt:o,s=e.transform,a=void 0===s?kt:s,c=e.delimiter,u=void 0===c?\" \":c,d=Pt(Pt(t,r,\"$1\\0$2\"),i,\"\\0\"),l=0,h=d.length;\"\\0\"===d.charAt(l);)l++;for(;\"\\0\"===d.charAt(h-1);)h--;return d.slice(l,h).split(\"\\0\").map(a).join(u)}(t,It({delimiter:\".\"},e))}class Tt{static fieldLayout(t,e){const n=void 0!==t.name?h(t.name):void 0;switch(t.type){case\"bool\":return f.bool(n);case\"u8\":return f.u8(n);case\"i8\":return f.i8(n);case\"u16\":return f.u16(n);case\"i16\":return f.i16(n);case\"u32\":return f.u32(n);case\"i32\":return f.i32(n);case\"f32\":return f.f32(n);case\"u64\":return f.u64(n);case\"i64\":return f.i64(n);case\"f64\":return f.f64(n);case\"u128\":return f.u128(n);case\"i128\":return f.i128(n);case\"bytes\":return f.vecU8(n);case\"string\":return f.str(n);case\"publicKey\":return f.publicKey(n);default:if(\"vec\"in t.type)return f.vec(Tt.fieldLayout({name:void 0,type:t.type.vec},e),n);if(\"option\"in t.type)return f.option(Tt.fieldLayout({name:void 0,type:t.type.option},e),n);if(\"defined\"in t.type){const r=t.type.defined;if(void 0===e)throw new gt(\"User defined types not provided\");const o=e.filter((t=>t.name===r));if(1!==o.length)throw new gt(`Type not found: ${JSON.stringify(t)}`);return Tt.typeDefLayout(o[0],e,n)}if(\"array\"in t.type){let r=t.type.array[0],o=t.type.array[1],i=Tt.fieldLayout({name:void 0,type:r},e);return f.array(i,o,n)}throw new Error(`Not yet implemented: ${t}`)}}static typeDefLayout(t,e=[],n){if(\"struct\"===t.type.kind){const r=t.type.fields.map((t=>Tt.fieldLayout(t,e)));return f.struct(r,n)}if(\"enum\"===t.type.kind){let r=t.type.variants.map((t=>{const n=h(t.name);if(void 0===t.fields)return f.struct([],n);const r=t.fields.map((t=>{if(!t.hasOwnProperty(\"name\"))throw new Error(\"Tuple enum variants not yet implemented.\");return Tt.fieldLayout(t,e)}));return f.struct(r,n)}));return void 0!==n?f.rustEnum(r).replicate(n):f.rustEnum(r,n)}throw new Error(`Unknown type kint: ${t}`)}}class Ct{constructor(t){this.idl=t,this.ixLayout=Ct.parseIxLayout(t);const e=new Map;t.instructions.forEach((t=>{const n=Bt(\"global\",t.name);e.set(d.encode(n),{layout:this.ixLayout.get(t.name),name:t.name})})),t.state&&t.state.methods.map((t=>{const n=Bt(\"state\",t.name);e.set(d.encode(n),{layout:this.ixLayout.get(t.name),name:t.name})})),this.sighashLayouts=e}encode(t,e){return this._encode(\"global\",t,e)}encodeState(t,e){return this._encode(\"state\",t,e)}_encode(e,n,r){const o=t.alloc(1e3),i=h(n),s=this.ixLayout.get(i);if(!s)throw new Error(`Unknown method: ${i}`);const a=s.encode(r,o),c=o.slice(0,a);return t.concat([Bt(e,n),c])}static parseIxLayout(t){const e=(t.state?t.state.methods:[]).map((e=>{let n=e.args.map((e=>{var n,r;return Tt.fieldLayout(e,Array.from([...null!==(n=t.accounts)&&void 0!==n?n:[],...null!==(r=t.types)&&void 0!==r?r:[]]))}));const r=h(e.name);return[r,f.struct(n,r)]})).concat(t.instructions.map((e=>{let n=e.args.map((e=>{var n,r;return Tt.fieldLayout(e,Array.from([...null!==(n=t.accounts)&&void 0!==n?n:[],...null!==(r=t.types)&&void 0!==r?r:[]]))}));const r=h(e.name);return[r,f.struct(n,r)]})));return new Map(e)}decode(e,n=\"hex\"){\"string\"==typeof e&&(e=\"hex\"===n?t.from(e,\"hex\"):d.decode(e));let r=d.encode(e.slice(0,8)),o=e.slice(8);const i=this.sighashLayouts.get(r);return i?{data:i.layout.decode(o),name:i.name}:null}format(t,e){return zt.format(t,e,this.idl)}}class zt{static format(t,e,n){const r=n.instructions.filter((e=>t.name===e.name))[0];if(void 0===r)return console.error(\"Invalid instruction given\"),null;const o=r.args.map((e=>({name:e.name,type:zt.formatIdlType(e.type),data:zt.formatIdlData(e,t.data[e.name],n.types)}))),i=zt.flattenIdlAccounts(r.accounts);return{args:o,accounts:e.map(((t,e)=>e<i.length?{name:i[e].name,...t}:{name:void 0,...t}))}}static formatIdlType(t){if(\"string\"==typeof t)return t;if(\"vec\"in t)return`Vec<${this.formatIdlType(t.vec)}>`;if(\"option\"in t)return`Option<${this.formatIdlType(t.option)}>`;if(\"defined\"in t)return t.defined;if(\"array\"in t)return`Array<${t.array[0]}; ${t.array[1]}>`;throw new Error(`Unknown IDL type: ${t}`)}static formatIdlData(t,e,n){if(\"string\"==typeof t.type)return e.toString();if(t.type.hasOwnProperty(\"vec\"))return\"[\"+e.map((e=>this.formatIdlData({name:\"\",type:t.type.vec},e))).join(\", \")+\"]\";if(t.type.hasOwnProperty(\"option\"))return null===e?\"null\":this.formatIdlData({name:\"\",type:t.type.option},e,n);if(t.type.hasOwnProperty(\"defined\")){if(void 0===n)throw new Error(\"User defined types not provided\");const r=n.filter((e=>e.name===t.type.defined));if(1!==r.length)throw new Error(`Type not found: ${t.type.defined}`);return zt.formatIdlDataDefined(r[0],e,n)}return\"unknown\"}static formatIdlDataDefined(t,e,n){if(\"struct\"===t.type.kind){const r=t.type;return\"{ \"+Object.keys(e).map((t=>{const o=r.fields.filter((e=>e.name===t))[0];if(void 0===o)throw new Error(\"Unable to find type\");return t+\": \"+zt.formatIdlData(o,e[t],n)})).join(\", \")+\" }\"}if(0===t.type.variants.length)return\"{}\";if(t.type.variants[0].name){const r=t.type.variants,o=Object.keys(e)[0],i=e[o],s=Object.keys(i).map((t=>{var e;const s=i[t],a=null===(e=r[o])||void 0===e?void 0:e.filter((e=>e.name===t))[0];if(void 0===a)throw new Error(\"Unable to find variant\");return t+\": \"+zt.formatIdlData(a,s,n)})).join(\", \"),a=h(o,{pascalCase:!0});return 0===s.length?a:`${a} { ${s} }`}return\"Tuple formatting not yet implemented\"}static flattenIdlAccounts(t,e){return t.map((t=>{const n=function(t){const e=t.replace(/([A-Z])/g,\" $1\");return e.charAt(0).toUpperCase()+e.slice(1)}(t.name);if(t.hasOwnProperty(\"accounts\")){const r=e?`${e} > ${n}`:n;return zt.flattenIdlAccounts(t.accounts,r)}return{...t,name:e?`${e} > ${n}`:n}})).flat()}}function Bt(e,n){var r;let o=`${e}:${void 0===r&&(r={}),Lt(n,Et({delimiter:\"_\"},r))}`;return t.from(p.digest(o)).slice(0,8)}function Ot(t,e){if(\"enum\"===e.type.kind){let n=e.type.variants.map((e=>void 0===e.fields?0:e.fields.map((e=>{if(\"object\"!=typeof e||!(\"name\"in e))throw new Error(\"Tuple enum variants not yet implemented.\");return Dt(t,e.type)})).reduce(((t,e)=>t+e))));return Math.max(...n)+1}return void 0===e.type.fields?0:e.type.fields.map((e=>Dt(t,e.type))).reduce(((t,e)=>t+e),0)}function Dt(t,e){var n,r;switch(e){case\"bool\":case\"u8\":case\"i8\":case\"bytes\":case\"string\":return 1;case\"i16\":case\"u16\":return 2;case\"u32\":case\"i32\":case\"f32\":return 4;case\"u64\":case\"i64\":case\"f64\":return 8;case\"u128\":case\"i128\":return 16;case\"publicKey\":return 32;default:if(\"vec\"in e)return 1;if(\"option\"in e)return 1+Dt(t,e.option);if(\"coption\"in e)return 4+Dt(t,e.coption);if(\"defined\"in e){const o=null!==(r=null===(n=t.types)||void 0===n?void 0:n.filter((t=>t.name===e.defined)))&&void 0!==r?r:[];if(1!==o.length)throw new gt(`Type not found: ${JSON.stringify(e)}`);return Ot(t,o[0])}if(\"array\"in e){let n=e.array[0],r=e.array[1];return Dt(t,n)*r}throw new Error(`Invalid type ${JSON.stringify(e)}`)}}const Nt=8;class Rt{constructor(t){if(void 0===t.accounts)return void(this.accountLayouts=new Map);const e=t.accounts.map((e=>[e.name,Tt.typeDefLayout(e,t.types)]));this.accountLayouts=new Map(e),this.idl=t}async encode(e,n){const r=t.alloc(1e3),o=this.accountLayouts.get(e);if(!o)throw new Error(`Unknown account: ${e}`);const i=o.encode(n,r);let s=r.slice(0,i),a=Rt.accountDiscriminator(e);return t.concat([a,s])}decode(t,e){if(Rt.accountDiscriminator(t).compare(e.slice(0,8)))throw new Error(\"Invalid account discriminator\");return this.decodeUnchecked(t,e)}decodeAny(t){const e=t.slice(0,8),n=Array.from(this.accountLayouts.keys()).find((t=>Rt.accountDiscriminator(t).equals(e)));if(!n)throw new Error(\"Account descriminator not found\");return this.decodeUnchecked(n,t)}decodeUnchecked(t,e){const n=e.slice(8),r=this.accountLayouts.get(t);if(!r)throw new Error(`Unknown account: ${t}`);return r.decode(n)}memcmp(e,n){const r=Rt.accountDiscriminator(e);return{offset:0,bytes:d.encode(n?t.concat([r,n]):r)}}size(t){var e;return 8+(null!==(e=Ot(this.idl,t))&&void 0!==e?e:0)}static accountDiscriminator(e){return t.from(p.digest(`account:${h(e,{pascalCase:!0})}`)).slice(0,8)}}class Vt{constructor(t){if(void 0===t.events)return void(this.layouts=new Map);const e=t.events.map((e=>{let n={name:e.name,type:{kind:\"struct\",fields:e.fields.map((t=>({name:t.name,type:t.type})))}};return[e.name,Tt.typeDefLayout(n,t.types)]}));this.layouts=new Map(e),this.discriminators=new Map(void 0===t.events?[]:t.events.map((t=>[l.fromByteArray(Ut(t.name)),t.name])))}decode(e){let n;try{n=t.from(l.toByteArray(e))}catch(t){return null}const r=l.fromByteArray(n.slice(0,8)),o=this.discriminators.get(r);if(void 0===o)return null;const i=this.layouts.get(o);if(!i)throw new Error(`Unknown event: ${o}`);return{data:i.decode(n.slice(8)),name:o}}}function Ut(e){return t.from(p.digest(`event:${e}`)).slice(0,8)}class jt{constructor(t){if(void 0===t.state)throw new Error(\"Idl state not defined.\");this.layout=Tt.typeDefLayout(t.state.struct,t.types)}async encode(e,n){const r=t.alloc(1e3),o=this.layout.encode(n,r),i=await $t(e),s=r.slice(0,o);return t.concat([i,s])}decode(t){const e=t.slice(8);return this.layout.decode(e)}}async function $t(e){let n=mt(\"anchor-deprecated-state\")?\"account\":\"state\";return t.from(p.digest(`${n}:${e}`)).slice(0,8)}class Kt{constructor(t){if(void 0===t.types)return void(this.typeLayouts=new Map);const e=t.types.map((e=>[e.name,Tt.typeDefLayout(e,t.types)]));this.typeLayouts=new Map(e),this.idl=t}encode(e,n){const r=t.alloc(1e3),o=this.typeLayouts.get(e);if(!o)throw new Error(`Unknown type: ${e}`);const i=o.encode(n,r);return r.slice(0,i)}decode(t,e){const n=this.typeLayouts.get(t);if(!n)throw new Error(`Unknown type: ${t}`);return n.decode(e)}}class qt{constructor(t){this.instruction=new Ct(t),this.accounts=new Rt(t),this.events=new Vt(t),t.state&&(this.state=new jt(t)),this.types=new Kt(t)}}var Ft=\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:{};function Wt(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,\"default\")?t.default:t}class Gt{constructor(t,e){if(!Number.isInteger(t))throw new TypeError(\"span must be an integer\");this.span=t,this.property=e}makeDestinationObject(){return{}}decode(t,e){throw new Error(\"Layout is abstract\")}encode(t,e,n){throw new Error(\"Layout is abstract\")}getSpan(t,e){if(0>this.span)throw new RangeError(\"indeterminate span\");return this.span}replicate(t){const e=Object.create(this.constructor.prototype);return Object.assign(e,this),e.property=t,e}fromArray(t){}}var Ht=Gt;class Jt extends Gt{isCount(){throw new Error(\"ExternalLayout is abstract\")}}class Zt extends Jt{constructor(t,e,n){if(!(t instanceof Gt))throw new TypeError(\"layout must be a Layout\");if(void 0===e)e=0;else if(!Number.isInteger(e))throw new TypeError(\"offset must be integer or undefined\");super(t.span,n||t.property),this.layout=t,this.offset=e}isCount(){return this.layout instanceof Xt||this.layout instanceof Qt}decode(t,e){return void 0===e&&(e=0),this.layout.decode(t,e+this.offset)}encode(t,e,n){return void 0===n&&(n=0),this.layout.encode(t,e,n+this.offset)}}class Xt extends Gt{constructor(t,e){if(super(t,e),6<this.span)throw new RangeError(\"span must not exceed 6 bytes\")}decode(t,e){return void 0===e&&(e=0),t.readUIntLE(e,this.span)}encode(t,e,n){return void 0===n&&(n=0),e.writeUIntLE(t,n,this.span),this.span}}class Qt extends Gt{constructor(t,e){if(super(t,e),6<this.span)throw new RangeError(\"span must not exceed 6 bytes\")}decode(t,e){return void 0===e&&(e=0),t.readUIntBE(e,this.span)}encode(t,e,n){return void 0===n&&(n=0),e.writeUIntBE(t,n,this.span),this.span}}const Yt=Math.pow(2,32);function te(t){const e=Math.floor(t/Yt);return{hi32:e,lo32:t-e*Yt}}function ee(t,e){return t*Yt+e}class ne extends Gt{constructor(t){super(8,t)}decode(t,e){void 0===e&&(e=0);const n=t.readUInt32LE(e);return ee(t.readUInt32LE(e+4),n)}encode(t,e,n){void 0===n&&(n=0);const r=te(t);return e.writeUInt32LE(r.lo32,n),e.writeUInt32LE(r.hi32,n+4),8}}class re extends Gt{constructor(t){super(8,t)}decode(t,e){void 0===e&&(e=0);const n=t.readUInt32LE(e);return ee(t.readInt32LE(e+4),n)}encode(t,e,n){void 0===n&&(n=0);const r=te(t);return e.writeUInt32LE(r.lo32,n),e.writeInt32LE(r.hi32,n+4),8}}class oe extends Gt{constructor(t,e,n){if(!Array.isArray(t)||!t.reduce(((t,e)=>t&&e instanceof Gt),!0))throw new TypeError(\"fields must be array of Layout instances\");\"boolean\"==typeof e&&void 0===n&&(n=e,e=void 0);for(const e of t)if(0>e.span&&void 0===e.property)throw new Error(\"fields cannot contain unnamed variable-length layout\");let r=-1;try{r=t.reduce(((t,e)=>t+e.getSpan()),0)}catch(t){}super(r,e),this.fields=t,this.decodePrefixes=!!n}getSpan(t,e){if(0<=this.span)return this.span;void 0===e&&(e=0);let n=0;try{n=this.fields.reduce(((n,r)=>{const o=r.getSpan(t,e);return e+=o,n+o}),0)}catch(t){throw new RangeError(\"indeterminate span\")}return n}decode(t,e){void 0===e&&(e=0);const n=this.makeDestinationObject();for(const r of this.fields)if(void 0!==r.property&&(n[r.property]=r.decode(t,e)),e+=r.getSpan(t,e),this.decodePrefixes&&t.length===e)break;return n}encode(t,e,n){void 0===n&&(n=0);const r=n;let o=0,i=0;for(const r of this.fields){let s=r.span;if(i=0<s?s:0,void 0!==r.property){const o=t[r.property];void 0!==o&&(i=r.encode(o,e,n),0>s&&(s=r.getSpan(e,n)))}o=n,n+=s}return o+i-r}fromArray(t){const e=this.makeDestinationObject();for(const n of this.fields)void 0!==n.property&&0<t.length&&(e[n.property]=t.shift());return e}layoutFor(t){if(\"string\"!=typeof t)throw new TypeError(\"property must be string\");for(const e of this.fields)if(e.property===t)return e}offsetOf(t){if(\"string\"!=typeof t)throw new TypeError(\"property must be string\");let e=0;for(const n of this.fields){if(n.property===t)return e;0>n.span?e=-1:0<=e&&(e+=n.span)}}}class ie{constructor(t){this.property=t}decode(){throw new Error(\"UnionDiscriminator is abstract\")}encode(){throw new Error(\"UnionDiscriminator is abstract\")}}class se extends ie{constructor(t,e){if(!(t instanceof Jt&&t.isCount()))throw new TypeError(\"layout must be an unsigned integer ExternalLayout\");super(e||t.property||\"variant\"),this.layout=t}decode(t,e){return this.layout.decode(t,e)}encode(t,e,n){return this.layout.encode(t,e,n)}}class ae extends Gt{constructor(t,e,n){const r=t instanceof Xt||t instanceof Qt;if(r)t=new se(new Zt(t));else if(t instanceof Jt&&t.isCount())t=new se(t);else if(!(t instanceof ie))throw new TypeError(\"discr must be a UnionDiscriminator or an unsigned integer layout\");if(void 0===e&&(e=null),!(null===e||e instanceof Gt))throw new TypeError(\"defaultLayout must be null or a Layout\");if(null!==e){if(0>e.span)throw new Error(\"defaultLayout must have constant span\");void 0===e.property&&(e=e.replicate(\"content\"))}let o=-1;e&&(o=e.span,0<=o&&r&&(o+=t.layout.span)),super(o,n),this.discriminator=t,this.usesPrefixDiscriminator=r,this.defaultLayout=e,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(t){return i(t)},this.configGetSourceVariant=function(t){i=t.bind(this)}}getSpan(t,e){if(0<=this.span)return this.span;void 0===e&&(e=0);const n=this.getVariant(t,e);if(!n)throw new Error(\"unable to determine span for unrecognized variant\");return n.getSpan(t,e)}defaultGetSourceVariant(t){if(t.hasOwnProperty(this.discriminator.property)){if(this.defaultLayout&&t.hasOwnProperty(this.defaultLayout.property))return;const e=this.registry[t[this.discriminator.property]];if(e&&(!e.layout||t.hasOwnProperty(e.property)))return e}else for(const e in this.registry){const n=this.registry[e];if(t.hasOwnProperty(n.property))return n}throw new Error(\"unable to infer src variant\")}decode(t,e){let n;void 0===e&&(e=0);const r=this.discriminator,o=r.decode(t,e);let i=this.registry[o];if(void 0===i){let s=0;i=this.defaultLayout,this.usesPrefixDiscriminator&&(s=r.layout.span),n=this.makeDestinationObject(),n[r.property]=o,n[i.property]=this.defaultLayout.decode(t,e+s)}else n=i.decode(t,e);return n}encode(t,e,n){void 0===n&&(n=0);const r=this.getSourceVariant(t);if(void 0===r){const r=this.discriminator,o=this.defaultLayout;let i=0;return this.usesPrefixDiscriminator&&(i=r.layout.span),r.encode(t[r.property],e,n),i+o.encode(t[o.property],e,n+i)}return r.encode(t,e,n)}addVariant(t,e,n){const r=new ce(this,t,e,n);return this.registry[t]=r,r}getVariant(t,e){let n=t;return Buffer.isBuffer(t)&&(void 0===e&&(e=0),n=this.discriminator.decode(t,e)),this.registry[n]}}class ce extends Gt{constructor(t,e,n,r){if(!(t instanceof ae))throw new TypeError(\"union must be a Union\");if(!Number.isInteger(e)||0>e)throw new TypeError(\"variant must be a (non-negative) integer\");if(\"string\"==typeof n&&void 0===r&&(r=n,n=null),n){if(!(n instanceof Gt))throw new TypeError(\"layout must be a Layout\");if(null!==t.defaultLayout&&0<=n.span&&n.span>t.defaultLayout.span)throw new Error(\"variant span exceeds span of containing union\");if(\"string\"!=typeof r)throw new TypeError(\"variant must have a String property\")}let o=t.span;0>t.span&&(o=n?n.span:0,0<=o&&t.usesPrefixDiscriminator&&(o+=t.discriminator.layout.span)),super(o,r),this.union=t,this.variant=e,this.layout=n||null}getSpan(t,e){if(0<=this.span)return this.span;void 0===e&&(e=0);let n=0;return this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),n+this.layout.getSpan(t,e+n)}decode(t,e){const n=this.makeDestinationObject();if(void 0===e&&(e=0),this!==this.union.getVariant(t,e))throw new Error(\"variant mismatch\");let r=0;return this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(t,e+r):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(t,e,n){void 0===n&&(n=0);let r=0;if(this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout&&!t.hasOwnProperty(this.property))throw new TypeError(\"variant lacks property \"+this.property);this.union.discriminator.encode(this.variant,e,n);let o=r;if(this.layout&&(this.layout.encode(t[this.property],e,n+r),o+=this.layout.getSpan(e,n+r),0<=this.union.span&&o>this.union.span))throw new Error(\"encoded variant overruns containing union\");return o}fromArray(t){if(this.layout)return this.layout.fromArray(t)}}class ue extends Gt{constructor(t,e){if(!(t instanceof Jt&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError(\"length must be positive integer or an unsigned integer ExternalLayout\");let n=-1;t instanceof Jt||(n=t),super(n,e),this.length=t}getSpan(t,e){let n=this.span;return 0>n&&(n=this.length.decode(t,e)),n}decode(t,e){void 0===e&&(e=0);let n=this.span;return 0>n&&(n=this.length.decode(t,e)),t.slice(e,e+n)}encode(t,e,n){let r=this.length;if(this.length instanceof Jt&&(r=t.length),!Buffer.isBuffer(t)||r!==t.length)throw new TypeError((o=\"Blob.encode\",((i=this).property?o+\"[\"+i.property+\"]\":o)+\" requires (length \"+r+\") Buffer as src\"));var o,i;if(n+r>e.length)throw new RangeError(\"encoding overruns Buffer\");return e.write(t.toString(\"hex\"),n,r,\"hex\"),this.length instanceof Jt&&this.length.encode(r,e,n),r}}var de=(t,e,n)=>new Zt(t,e,n),le=t=>new Xt(1,t),he=t=>new Xt(4,t),pe=t=>new ne(t),fe=t=>new re(t),me=(t,e,n)=>new oe(t,e,n),ye=(t,e,n)=>new ae(t,e,n),ge=(t,e)=>new ue(t,e);class we{constructor(t){}encode(t,n){switch(h(t)){case\"initializeMint\":return function({decimals:t,mintAuthority:n,freezeAuthority:r}){return Ae({initializeMint:{decimals:t,mintAuthority:n.toBuffer(),freezeAuthorityOption:!!r,freezeAuthority:(r||e.default).toBuffer()}})}(n);case\"initializeAccount\":return Ae({initializeAccount:{}});case\"initializeMultisig\":return function({m:t}){return Ae({initializeMultisig:{m:t}})}(n);case\"transfer\":return function({amount:t}){return Ae({transfer:{amount:t}})}(n);case\"approve\":return function({amount:t}){return Ae({approve:{amount:t}})}(n);case\"revoke\":return Ae({revoke:{}});case\"setAuthority\":return function({authorityType:t,newAuthority:e}){return Ae({setAuthority:{authorityType:t,newAuthority:e}})}(n);case\"mintTo\":return function({amount:t}){return Ae({mintTo:{amount:t}})}(n);case\"burn\":return function({amount:t}){return Ae({burn:{amount:t}})}(n);case\"closeAccount\":return Ae({closeAccount:{}});case\"freezeAccount\":return Ae({freezeAccount:{}});case\"thawAccount\":return Ae({thawAccount:{}});case\"transferChecked\":return function({amount:t,decimals:e}){return Ae({transferChecked:{amount:t,decimals:e}})}(n);case\"approvedChecked\":return function({amount:t,decimals:e}){return Ae({approveChecked:{amount:t,decimals:e}})}(n);case\"mintToChecked\":return function({amount:t,decimals:e}){return Ae({mintToChecked:{amount:t,decimals:e}})}(n);case\"burnChecked\":return function({amount:t,decimals:e}){return Ae({burnChecked:{amount:t,decimals:e}})}(n);case\"intializeAccount2\":return function({authority:t}){return Ae({initilaizeAccount2:{authority:t}})}(n);case\"syncNative\":return Ae({syncNative:{}});case\"initializeAccount3\":return function({authority:t}){return Ae({initializeAccount3:{authority:t}})}(n);case\"initializeMultisig2\":return function({m:t}){return Ae({initializeMultisig2:{m:t}})}(n);case\"initializeMint2\":return function({decimals:t,mintAuthority:e,freezeAuthority:n}){return Ae({encodeInitializeMint2:{decimals:t,mintAuthority:e,freezeAuthority:n}})}(n);default:throw new Error(`Invalid instruction: ${t}`)}}encodeState(t,e){throw new Error(\"SPL token does not have state\")}}const ve=ye(le(\"instruction\"));function be(t){return ge(32,t)}function Ae(t){let e=Buffer.alloc(_e),n=ve.encode(t,e);return e.slice(0,n)}ve.addVariant(0,me([le(\"decimals\"),ge(32,\"mintAuthority\"),le(\"freezeAuthorityOption\"),be(\"freezeAuthority\")]),\"initializeMint\"),ve.addVariant(1,me([]),\"initializeAccount\"),ve.addVariant(2,me([le(\"m\")]),\"initializeMultisig\"),ve.addVariant(3,me([pe(\"amount\")]),\"transfer\"),ve.addVariant(4,me([pe(\"amount\")]),\"approve\"),ve.addVariant(5,me([]),\"revoke\"),ve.addVariant(6,me([le(\"authorityType\"),le(\"newAuthorityOption\"),be(\"newAuthority\")]),\"setAuthority\"),ve.addVariant(7,me([pe(\"amount\")]),\"mintTo\"),ve.addVariant(8,me([pe(\"amount\")]),\"burn\"),ve.addVariant(9,me([]),\"closeAccount\"),ve.addVariant(10,me([]),\"freezeAccount\"),ve.addVariant(11,me([]),\"thawAccount\"),ve.addVariant(12,me([pe(\"amount\"),le(\"decimals\")]),\"transferChecked\"),ve.addVariant(13,me([pe(\"amount\"),le(\"decimals\")]),\"approvedChecked\"),ve.addVariant(14,me([pe(\"amount\"),le(\"decimals\")]),\"mintToChecked\"),ve.addVariant(15,me([pe(\"amount\"),le(\"decimals\")]),\"burnedChecked\"),ve.addVariant(16,me([be(\"authority\")]),\"InitializeAccount2\"),ve.addVariant(17,me([]),\"syncNative\"),ve.addVariant(18,me([be(\"authority\")]),\"initializeAccount3\"),ve.addVariant(19,me([le(\"m\")]),\"initializeMultisig2\"),ve.addVariant(20,me([le(\"decimals\"),be(\"mintAuthority\"),le(\"freezeAuthorityOption\"),be(\"freezeAuthority\")]),\"initializeMint2\");const _e=Math.max(...Object.values(ve.registry).map((t=>t.span)));class Se{constructor(t){}encode(t,e){throw new Error(\"SPL token does not have state\")}decode(t){throw new Error(\"SPL token does not have state\")}}function Ee(t){return new xe(ge(8),(t=>Te.fromBuffer(t)),(t=>t.toBuffer()),t)}function Ie(t){return new xe(ge(32),(t=>new e(t)),(t=>t.toBuffer()),t)}function ke(t,e){return new Me(t,e)}class xe extends Ht{constructor(t,e,n,r){super(t.span,r),this.layout=t,this.decoder=e,this.encoder=n}decode(t,e){return this.decoder(this.layout.decode(t,e))}encode(t,e,n){return this.layout.encode(this.encoder(t),e,n)}getSpan(t,e){return this.layout.getSpan(t,e)}}class Me extends Ht{constructor(t,e){super(-1,e),this.layout=t,this.discriminator=he()}encode(t,e,n=0){return null==t?this.layout.span+this.discriminator.encode(0,e,n):(this.discriminator.encode(1,e,n),this.layout.encode(t,e,n+4)+4)}decode(t,e=0){const n=this.discriminator.decode(t,e);if(0===n)return null;if(1===n)return this.layout.decode(t,e+4);throw new Error(\"Invalid coption \"+this.layout.property)}getSpan(t,e=0){return this.layout.getSpan(t,e+4)+4}}function Pe(t){if(0===t)return!1;if(1===t)return!0;throw new Error(\"Invalid bool: \"+t)}function Le(t){return t?1:0}class Te extends u{toBuffer(){const t=super.toArray().reverse(),e=Buffer.from(t);if(8===e.length)return e;if(e.length>=8)throw new Error(\"u64 too large\");const n=Buffer.alloc(8);return e.copy(n),n}static fromBuffer(t){if(8!==t.length)throw new Error(`Invalid buffer length: ${t.length}`);return new Te([...t].reverse().map((t=>`00${t.toString(16)}`.slice(-2))).join(\"\"),16)}}class Ce{constructor(t){this.idl=t}async encode(t,e){switch(t){case\"token\":{const t=Buffer.alloc(165),n=Oe.encode(e,t);return t.slice(0,n)}case\"mint\":{const t=Buffer.alloc(82),n=ze.encode(e,t);return t.slice(0,n)}default:throw new Error(`Invalid account name: ${t}`)}}decode(t,e){return this.decodeUnchecked(t,e)}decodeUnchecked(t,e){switch(t){case\"token\":return function(t){return Oe.decode(t)}(e);case\"mint\":return function(t){return ze.decode(t)}(e);default:throw new Error(`Invalid account name: ${t}`)}}memcmp(t,e){switch(t){case\"token\":return{dataSize:165};case\"mint\":return{dataSize:82};default:throw new Error(`Invalid account name: ${t}`)}}size(t){var e;return null!==(e=Ot(this.idl,t))&&void 0!==e?e:0}}const ze=me([ke(Ie(),\"mintAuthority\"),Ee(\"supply\"),le(\"decimals\"),(Be=\"isInitialized\",new xe(le(),Pe,Le,Be)),ke(Ie(),\"freezeAuthority\")]);var Be;const Oe=me([Ie(\"mint\"),Ie(\"authority\"),Ee(\"amount\"),ke(Ie(),\"delegate\"),le(\"state\"),ke(Ee(),\"isNative\"),Ee(\"delegatedAmount\"),ke(Ie(),\"closeAuthority\")]);class De{constructor(t){}decode(t){throw new Error(\"SPL token program does not have events\")}}class Ne{constructor(t){}encode(t,e){throw new Error(\"SPL token does not have user-defined types\")}decode(t,e){throw new Error(\"SPL token does not have user-defined types\")}}class Re{constructor(t){this.instruction=new we(t),this.accounts=new Ce(t),this.events=new De(t),this.state=new Se(t),this.types=new Ne(t)}}class Ve{constructor(t){}encode(t,e){switch(h(t)){case\"createAccount\":return function({lamports:t,space:e,owner:n}){return qe({createAccount:{lamports:t,space:e,owner:n.toBuffer()}})}(e);case\"assign\":return function({owner:t}){return qe({assign:{owner:t.toBuffer()}})}(e);case\"transfer\":return function({lamports:t}){return qe({transfer:{lamports:t}})}(e);case\"createAccountWithSeed\":return function({base:t,seed:e,lamports:n,space:r,owner:o}){return qe({createAccountWithSeed:{base:t.toBuffer(),seed:e,lamports:n,space:r,owner:o.toBuffer()}},Ke.getVariant(3).span+e.length)}(e);case\"advanceNonceAccount\":return function({authorized:t}){return qe({advanceNonceAccount:{authorized:t.toBuffer()}})}(e);case\"withdrawNonceAccount\":return function({lamports:t}){return qe({withdrawNonceAccount:{lamports:t}})}(e);case\"initializeNonceAccount\":return function({authorized:t}){return qe({initializeNonceAccount:{authorized:t.toBuffer()}})}(e);case\"authorizeNonceAccount\":return function({authorized:t}){return qe({authorizeNonceAccount:{authorized:t.toBuffer()}})}(e);case\"allocate\":return function({space:t}){return qe({allocate:{space:t}})}(e);case\"allocateWithSeed\":return function({base:t,seed:e,space:n,owner:r}){return qe({allocateWithSeed:{base:t.toBuffer(),seed:e,space:n,owner:r.toBuffer()}},Ke.getVariant(9).span+e.length)}(e);case\"assignWithSeed\":return function({base:t,seed:e,owner:n}){return qe({assignWithSeed:{base:t.toBuffer(),seed:e,owner:n.toBuffer()}},Ke.getVariant(10).span+e.length)}(e);case\"transferWithSeed\":return function({lamports:t,seed:e,owner:n}){return qe({transferWithSeed:{lamports:t,seed:e,owner:n.toBuffer()}},Ke.getVariant(11).span+e.length)}(e);default:throw new Error(`Invalid instruction: ${t}`)}}encodeState(t,e){throw new Error(\"System does not have state\")}}class Ue extends Ht{constructor(t){super(-1,t),this.property=t,this.layout=me([he(\"length\"),he(\"lengthPadding\"),ge(de(he(),-8),\"chars\")],this.property)}encode(t,e,n=0){if(null==t)return this.layout.span;const r={chars:Buffer.from(t,\"utf8\")};return this.layout.encode(r,e,n)}decode(t,e=0){return this.layout.decode(t,e).chars.toString()}getSpan(t,e=0){return he().span+he().span+new u(new Uint8Array(t).slice(e,e+4),10,\"le\").toNumber()}}function je(t){return new Ue(t)}function $e(t){return ge(32,t)}const Ke=ye(he(\"instruction\"));function qe(t,e){const n=Buffer.alloc(null!=e?e:Fe),r=Ke.encode(t,n);return void 0===e?n.slice(0,r):n}Ke.addVariant(0,me([fe(\"lamports\"),fe(\"space\"),$e(\"owner\")]),\"createAccount\"),Ke.addVariant(1,me([$e(\"owner\")]),\"assign\"),Ke.addVariant(2,me([fe(\"lamports\")]),\"transfer\"),Ke.addVariant(3,me([$e(\"base\"),je(\"seed\"),fe(\"lamports\"),fe(\"space\"),$e(\"owner\")]),\"createAccountWithSeed\"),Ke.addVariant(4,me([$e(\"authorized\")]),\"advanceNonceAccount\"),Ke.addVariant(5,me([fe(\"lamports\")]),\"withdrawNonceAccount\"),Ke.addVariant(6,me([$e(\"authorized\")]),\"initializeNonceAccount\"),Ke.addVariant(7,me([$e(\"authorized\")]),\"authorizeNonceAccount\"),Ke.addVariant(8,me([fe(\"space\")]),\"allocate\"),Ke.addVariant(9,me([$e(\"base\"),je(\"seed\"),fe(\"space\"),$e(\"owner\")]),\"allocateWithSeed\"),Ke.addVariant(10,me([$e(\"base\"),je(\"seed\"),$e(\"owner\")]),\"assignWithSeed\"),Ke.addVariant(11,me([fe(\"lamports\"),je(\"seed\"),$e(\"owner\")]),\"transferWithSeed\");const Fe=Math.max(...Object.values(Ke.registry).map((t=>t.span)));class We{constructor(t){}encode(t,e){throw new Error(\"System does not have state\")}decode(t){throw new Error(\"System does not have state\")}}class Ge{constructor(t){this.idl=t}async encode(t,e){if(\"nonce\"===t){const t=Buffer.alloc(i),n=Ze.encode(e,t);return t.slice(0,n)}throw new Error(`Invalid account name: ${t}`)}decode(t,e){return this.decodeUnchecked(t,e)}decodeUnchecked(t,e){if(\"nonce\"===t)return function(t){return Ze.decode(t)}(e);throw new Error(`Invalid account name: ${t}`)}memcmp(t,e){if(\"nonce\"===t)return{dataSize:i};throw new Error(`Invalid account name: ${t}`)}size(t){var e;return null!==(e=Ot(this.idl,t))&&void 0!==e?e:0}}class He extends Ht{constructor(t,e,n,r){super(t.span,r),this.layout=t,this.decoder=e,this.encoder=n}decode(t,e){return this.decoder(this.layout.decode(t,e))}encode(t,e,n){return this.layout.encode(this.encoder(t),e,n)}getSpan(t,e){return this.layout.getSpan(t,e)}}function Je(t){return new He(ge(32),(t=>new e(t)),(t=>t.toBuffer()),t)}const Ze=me([he(\"version\"),he(\"state\"),Je(\"authorizedPubkey\"),Je(\"nonce\"),me([pe(\"lamportsPerSignature\")],\"feeCalculator\")]);class Xe{constructor(t){}decode(t){throw new Error(\"System program does not have events\")}}class Qe{constructor(t){}encode(t,e){throw new Error(\"System does not have user-defined types\")}decode(t,e){throw new Error(\"System does not have user-defined types\")}}class Ye{constructor(t){this.instruction=new Ve(t),this.accounts=new Ge(t),this.events=new Xe(t),this.state=new We(t),this.types=new Qe(t)}}var tn=Object.freeze({__proto__:null,hash:function(t){return p(t)}});function en(n,r,o){const i=t.concat([n.toBuffer(),t.from(r),o.toBuffer()]),s=p.digest(i);return new e(t.from(s))}function nn(n,r){let o=t.alloc(0);n.forEach((function(e){if(e.length>32)throw new TypeError(\"Max seed length exceeded\");o=t.concat([o,on(e)])})),o=t.concat([o,r.toBuffer(),t.from(\"ProgramDerivedAddress\")]);let i=p(new Uint8Array(o)),s=new u(i,16).toArray(void 0,32);if(e.isOnCurve(new Uint8Array(s)))throw new Error(\"Invalid seeds, address must fall off the curve\");return new e(s)}function rn(e,n){let r,o=255;for(;0!=o;){try{r=nn(e.concat(t.from([o])),n)}catch(t){if(t instanceof TypeError)throw t;o--;continue}return[r,o]}throw new Error(\"Unable to find a viable program address nonce\")}const on=e=>e instanceof t?e:e instanceof Uint8Array?t.from(e.buffer,e.byteOffset,e.byteLength):t.from(e);async function sn(n,...r){let o=[t.from([97,110,99,104,111,114])];r.forEach((e=>{o.push(e instanceof t?e:L(e).toBuffer())}));const[i]=await e.findProgramAddress(o,L(n));return i}var an=Object.freeze({__proto__:null,createWithSeedSync:en,createProgramAddressSync:nn,findProgramAddressSync:rn,associated:sn});const cn=new e(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"),un=new e(\"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\");var dn=Object.freeze({__proto__:null,TOKEN_PROGRAM_ID:cn,ASSOCIATED_PROGRAM_ID:un,associatedAddress:async function({mint:t,owner:n}){return(await e.findProgramAddress([n.toBuffer(),cn.toBuffer(),t.toBuffer()],un))[0]}}),ln={exports:{}};!function(t,e){var n=\"undefined\"!=typeof self?self:Ft,r=function(){function t(){this.fetch=!1,this.DOMException=n.DOMException}return t.prototype=n,new t}();!function(t){!function(e){var n=\"URLSearchParams\"in t,r=\"Symbol\"in t&&\"iterator\"in Symbol,o=\"FileReader\"in t&&\"Blob\"in t&&function(){try{return new Blob,!0}catch(t){return!1}}(),i=\"FormData\"in t,s=\"ArrayBuffer\"in t;if(s)var a=[\"[object Int8Array]\",\"[object Uint8Array]\",\"[object Uint8ClampedArray]\",\"[object Int16Array]\",\"[object Uint16Array]\",\"[object Int32Array]\",\"[object Uint32Array]\",\"[object Float32Array]\",\"[object Float64Array]\"],c=ArrayBuffer.isView||function(t){return t&&a.indexOf(Object.prototype.toString.call(t))>-1};function u(t){if(\"string\"!=typeof t&&(t=String(t)),/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(t))throw new TypeError(\"Invalid character in header field name\");return t.toLowerCase()}function d(t){return\"string\"!=typeof t&&(t=String(t)),t}function l(t){var e={next:function(){var e=t.shift();return{done:void 0===e,value:e}}};return r&&(e[Symbol.iterator]=function(){return e}),e}function h(t){this.map={},t instanceof h?t.forEach((function(t,e){this.append(e,t)}),this):Array.isArray(t)?t.forEach((function(t){this.append(t[0],t[1])}),this):t&&Object.getOwnPropertyNames(t).forEach((function(e){this.append(e,t[e])}),this)}function p(t){if(t.bodyUsed)return Promise.reject(new TypeError(\"Already read\"));t.bodyUsed=!0}function f(t){return new Promise((function(e,n){t.onload=function(){e(t.result)},t.onerror=function(){n(t.error)}}))}function m(t){var e=new FileReader,n=f(e);return e.readAsArrayBuffer(t),n}function y(t){if(t.slice)return t.slice(0);var e=new Uint8Array(t.byteLength);return e.set(new Uint8Array(t)),e.buffer}function g(){return this.bodyUsed=!1,this._initBody=function(t){var e;this._bodyInit=t,t?\"string\"==typeof t?this._bodyText=t:o&&Blob.prototype.isPrototypeOf(t)?this._bodyBlob=t:i&&FormData.prototype.isPrototypeOf(t)?this._bodyFormData=t:n&&URLSearchParams.prototype.isPrototypeOf(t)?this._bodyText=t.toString():s&&o&&((e=t)&&DataView.prototype.isPrototypeOf(e))?(this._bodyArrayBuffer=y(t.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):s&&(ArrayBuffer.prototype.isPrototypeOf(t)||c(t))?this._bodyArrayBuffer=y(t):this._bodyText=t=Object.prototype.toString.call(t):this._bodyText=\"\",this.headers.get(\"content-type\")||(\"string\"==typeof t?this.headers.set(\"content-type\",\"text/plain;charset=UTF-8\"):this._bodyBlob&&this._bodyBlob.type?this.headers.set(\"content-type\",this._bodyBlob.type):n&&URLSearchParams.prototype.isPrototypeOf(t)&&this.headers.set(\"content-type\",\"application/x-www-form-urlencoded;charset=UTF-8\"))},o&&(this.blob=function(){var t=p(this);if(t)return t;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error(\"could not read FormData body as blob\");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?p(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(m)}),this.text=function(){var t=p(this);if(t)return t;if(this._bodyBlob)return function(t){var e=new FileReader,n=f(e);return e.readAsText(t),n}(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(function(t){for(var e=new Uint8Array(t),n=new Array(e.length),r=0;r<e.length;r++)n[r]=String.fromCharCode(e[r]);return n.join(\"\")}(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error(\"could not read FormData body as text\");return Promise.resolve(this._bodyText)},i&&(this.formData=function(){return this.text().then(b)}),this.json=function(){return this.text().then(JSON.parse)},this}h.prototype.append=function(t,e){t=u(t),e=d(e);var n=this.map[t];this.map[t]=n?n+\", \"+e:e},h.prototype.delete=function(t){delete this.map[u(t)]},h.prototype.get=function(t){return t=u(t),this.has(t)?this.map[t]:null},h.prototype.has=function(t){return this.map.hasOwnProperty(u(t))},h.prototype.set=function(t,e){this.map[u(t)]=d(e)},h.prototype.forEach=function(t,e){for(var n in this.map)this.map.hasOwnProperty(n)&&t.call(e,this.map[n],n,this)},h.prototype.keys=function(){var t=[];return this.forEach((function(e,n){t.push(n)})),l(t)},h.prototype.values=function(){var t=[];return this.forEach((function(e){t.push(e)})),l(t)},h.prototype.entries=function(){var t=[];return this.forEach((function(e,n){t.push([n,e])})),l(t)},r&&(h.prototype[Symbol.iterator]=h.prototype.entries);var w=[\"DELETE\",\"GET\",\"HEAD\",\"OPTIONS\",\"POST\",\"PUT\"];function v(t,e){var n,r,o=(e=e||{}).body;if(t instanceof v){if(t.bodyUsed)throw new TypeError(\"Already read\");this.url=t.url,this.credentials=t.credentials,e.headers||(this.headers=new h(t.headers)),this.method=t.method,this.mode=t.mode,this.signal=t.signal,o||null==t._bodyInit||(o=t._bodyInit,t.bodyUsed=!0)}else this.url=String(t);if(this.credentials=e.credentials||this.credentials||\"same-origin\",!e.headers&&this.headers||(this.headers=new h(e.headers)),this.method=(n=e.method||this.method||\"GET\",r=n.toUpperCase(),w.indexOf(r)>-1?r:n),this.mode=e.mode||this.mode||null,this.signal=e.signal||this.signal,this.referrer=null,(\"GET\"===this.method||\"HEAD\"===this.method)&&o)throw new TypeError(\"Body not allowed for GET or HEAD requests\");this._initBody(o)}function b(t){var e=new FormData;return t.trim().split(\"&\").forEach((function(t){if(t){var n=t.split(\"=\"),r=n.shift().replace(/\\+/g,\" \"),o=n.join(\"=\").replace(/\\+/g,\" \");e.append(decodeURIComponent(r),decodeURIComponent(o))}})),e}function A(t,e){e||(e={}),this.type=\"default\",this.status=void 0===e.status?200:e.status,this.ok=this.status>=200&&this.status<300,this.statusText=\"statusText\"in e?e.statusText:\"OK\",this.headers=new h(e.headers),this.url=e.url||\"\",this._initBody(t)}v.prototype.clone=function(){return new v(this,{body:this._bodyInit})},g.call(v.prototype),g.call(A.prototype),A.prototype.clone=function(){return new A(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new h(this.headers),url:this.url})},A.error=function(){var t=new A(null,{status:0,statusText:\"\"});return t.type=\"error\",t};var _=[301,302,303,307,308];A.redirect=function(t,e){if(-1===_.indexOf(e))throw new RangeError(\"Invalid status code\");return new A(null,{status:e,headers:{location:t}})},e.DOMException=t.DOMException;try{new e.DOMException}catch(t){e.DOMException=function(t,e){this.message=t,this.name=e;var n=Error(t);this.stack=n.stack},e.DOMException.prototype=Object.create(Error.prototype),e.DOMException.prototype.constructor=e.DOMException}function S(t,n){return new Promise((function(r,i){var s=new v(t,n);if(s.signal&&s.signal.aborted)return i(new e.DOMException(\"Aborted\",\"AbortError\"));var a=new XMLHttpRequest;function c(){a.abort()}a.onload=function(){var t,e,n={status:a.status,statusText:a.statusText,headers:(t=a.getAllResponseHeaders()||\"\",e=new h,t.replace(/\\r?\\n[\\t ]+/g,\" \").split(/\\r?\\n/).forEach((function(t){var n=t.split(\":\"),r=n.shift().trim();if(r){var o=n.join(\":\").trim();e.append(r,o)}})),e)};n.url=\"responseURL\"in a?a.responseURL:n.headers.get(\"X-Request-URL\");var o=\"response\"in a?a.response:a.responseText;r(new A(o,n))},a.onerror=function(){i(new TypeError(\"Network request failed\"))},a.ontimeout=function(){i(new TypeError(\"Network request failed\"))},a.onabort=function(){i(new e.DOMException(\"Aborted\",\"AbortError\"))},a.open(s.method,s.url,!0),\"include\"===s.credentials?a.withCredentials=!0:\"omit\"===s.credentials&&(a.withCredentials=!1),\"responseType\"in a&&o&&(a.responseType=\"blob\"),s.headers.forEach((function(t,e){a.setRequestHeader(e,t)})),s.signal&&(s.signal.addEventListener(\"abort\",c),a.onreadystatechange=function(){4===a.readyState&&s.signal.removeEventListener(\"abort\",c)}),a.send(void 0===s._bodyInit?null:s._bodyInit)}))}S.polyfill=!0,t.fetch||(t.fetch=S,t.Headers=h,t.Request=v,t.Response=A),e.Headers=h,e.Request=v,e.Response=A,e.fetch=S,Object.defineProperty(e,\"__esModule\",{value:!0})}({})}(r),r.fetch.ponyfill=!0,delete r.fetch.polyfill;var o=r;(e=o.fetch).default=o.fetch,e.fetch=o.fetch,e.Headers=o.Headers,e.Request=o.Request,e.Response=o.Response,t.exports=e}(ln,ln.exports);var hn=Wt(ln.exports);async function pn(t,e){const n=await t.getAccountInfo(e);if(null===n)throw new Error(\"program account not found\");const{program:r}=mn(n.data),o=await t.getAccountInfo(r.programdataAddress);if(null===o)throw new Error(\"program data account not found\");const{programData:i}=mn(o.data);return i}const fn=f.rustEnum([f.struct([],\"uninitialized\"),f.struct([f.option(f.publicKey(),\"authorityAddress\")],\"buffer\"),f.struct([f.publicKey(\"programdataAddress\")],\"program\"),f.struct([f.u64(\"slot\"),f.option(f.publicKey(),\"upgradeAuthorityAddress\")],\"programData\")],void 0,f.u32());function mn(t){return fn.decode(t)}var yn=Object.freeze({__proto__:null,verifiedBuild:async function(t,e,n=5){const r=`https://api.apr.dev/api/v0/program/${e.toString()}/latest?limit=${n}`,[o,i]=await Promise.all([pn(t,e),hn(r)]),s=(await i.json()).filter((t=>!t.aborted&&\"Built\"===t.state&&\"Verified\"===t.verified));if(0===s.length)return null;const a=s[0];return o.slot.toNumber()!==a.verified_slot?null:a},fetchData:pn,decodeUpgradeableLoaderState:mn}),gn=Object.freeze({__proto__:null,sha256:tn,rpc:it,publicKey:an,bytes:k,token:dn,features:yt,registry:yn});const wn=f.struct([f.publicKey(\"authority\"),f.vecU8(\"data\")]);function vn(t,e){var n,r;let o={};const i=t.args?t.args.length:0;if(e.length>i){if(e.length!==i+1)throw new Error(`provided too many arguments ${e} to instruction ${null==t?void 0:t.name} expecting: ${null!==(r=null===(n=t.args)||void 0===n?void 0:n.map((t=>t.name)))&&void 0!==r?r:[]}`);o=e.pop()}return[e,o]}class bn{static build(t,e,n){if(\"_inner\"===t.name)throw new gt(\"the _inner name is reserved\");const o=(...i)=>{const[s,a]=vn(t,[...i]);P(t.accounts,a.accounts);const c=o.accounts(a.accounts);return void 0!==a.remainingAccounts&&c.push(...a.remainingAccounts),mt(\"debug-logs\")&&console.log(\"Outgoing account metas:\",c),new r({keys:c,programId:n,data:e(t.name,M(t,...s))})};return o.accounts=e=>bn.accountsArray(e,t.accounts,t.name),o}static accountsArray(t,e,n){return t?e.map((e=>{if(void 0!==(\"accounts\"in e?e.accounts:void 0)){const r=t[e.name];return bn.accountsArray(r,e.accounts,n).flat()}{const r=e;let o;try{o=L(t[e.name])}catch(t){throw new Error(`Wrong input type for account \"${e.name}\" in the instruction accounts object${void 0!==n?' for instruction \"'+n+'\"':\"\"}. Expected PublicKey or string.`)}return{pubkey:o,isWritable:r.isMut,isSigner:r.isSigner}}})).flat():[]}}class An{static build(t,e,n,r){return async(...o)=>{var i;const s=e(...o),[,a]=vn(t,[...o]);if(void 0===r.sendAndConfirm)throw new Error(\"This function requires 'Provider.sendAndConfirm' to be implemented.\");try{return await r.sendAndConfirm(s,null!==(i=a.signers)&&void 0!==i?i:[],a.options)}catch(t){throw At(t,n)}}}}class _n{static build(t,e){return(...r)=>{var o,i,s;const[,a]=vn(t,[...r]),c=new n;if(a.preInstructions&&a.instructions)throw new Error(\"instructions is deprecated, use preInstructions\");return null===(o=a.preInstructions)||void 0===o||o.forEach((t=>c.add(t))),null===(i=a.instructions)||void 0===i||i.forEach((t=>c.add(t))),c.add(e(...r)),null===(s=a.postInstructions)||void 0===s||s.forEach((t=>c.add(t))),c}}}class Sn{constructor(t,e,n=lt(),r=new qt(t)){this.provider=n,this.coder=r,this._idl=t,this._programId=e,this._address=En(e),this._sub=null;const[o,i,a]=(()=>{var o;let i={},a={},c={};return null===(o=t.state)||void 0===o||o.methods.forEach((o=>{const u=bn.build(o,((t,e)=>r.instruction.encodeState(t,e)),e);u.accounts=t=>{const r=function(t,e,n,r){if(\"new\"===n.name){const[n]=rn([],t);if(void 0===e.wallet)throw new Error(\"This function requires the Provider interface implementor to have a 'wallet' field.\");return[{pubkey:e.wallet.publicKey,isWritable:!1,isSigner:!0},{pubkey:En(t),isWritable:!0,isSigner:!1},{pubkey:n,isWritable:!1,isSigner:!1},{pubkey:s.programId,isWritable:!1,isSigner:!1},{pubkey:t,isWritable:!1,isSigner:!1}]}return P(n.accounts,r),[{pubkey:En(t),isWritable:!0,isSigner:!1}]}(e,n,o,t);return r.concat(bn.accountsArray(t,o.accounts,o.name))};const d=_n.build(o,u),l=An.build(o,d,x(t),n),p=h(o.name);i[p]=u,a[p]=d,c[p]=l})),[i,a,c]})();this.instruction=o,this.transaction=i,this.rpc=a}get programId(){return this._programId}async fetch(){const t=this.address(),e=await this.provider.connection.getAccountInfo(t);if(null===e)throw new Error(`Account does not exist ${t.toString()}`);const n=this._idl.state;if(!n)throw new Error(\"State is not specified in IDL.\");if((await $t(n.struct.name)).compare(e.data.slice(0,8)))throw new Error(\"Invalid account discriminator\");return this.coder.state.decode(e.data)}address(){return this._address}subscribe(t){if(null!==this._sub)return this._sub.ee;const e=new y,n=this.provider.connection.onAccountChange(this.address(),(t=>{const n=this.coder.state.decode(t.data);e.emit(\"change\",n)}),t);return this._sub={ee:e,listener:n},e}unsubscribe(){null!==this._sub&&this.provider.connection.removeAccountChangeListener(this._sub.listener).then((async()=>{this._sub=null})).catch(console.error)}}function En(t){let[e]=rn([],t);return en(e,\"unversioned\",t)}class In{constructor(t,e,n,r,o){this._idlAccount=e,this._programId=n,this._provider=null!=r?r:lt(),this._coder=null!=o?o:new qt(t),this._size=this._coder.accounts.size(e)}get size(){return this._size}get programId(){return this._programId}get provider(){return this._provider}get coder(){return this._coder}async fetchNullable(t,e){const n=await this.getAccountInfo(t,e);return null===n?null:this._coder.accounts.decode(this._idlAccount.name,n.data)}async fetch(t,e){const n=await this.fetchNullable(t,e);if(null===n)throw new Error(`Account does not exist ${t.toString()}`);return n}async fetchMultiple(t,e){return(await X(this._provider.connection,t.map((t=>L(t))),e)).map((t=>null==t?null:this._coder.accounts.decode(this._idlAccount.name,null==t?void 0:t.account.data)))}async all(t){const e=this.coder.accounts.memcmp(this._idlAccount.name,t instanceof Buffer?t:void 0),n=[];return null!=(null==e?void 0:e.offset)&&null!=(null==e?void 0:e.bytes)&&n.push({memcmp:{offset:e.offset,bytes:e.bytes}}),null!=(null==e?void 0:e.dataSize)&&n.push({dataSize:e.dataSize}),(await this._provider.connection.getProgramAccounts(this._programId,{commitment:this._provider.connection.commitment,filters:[...n,...Array.isArray(t)?t:[]]})).map((({pubkey:t,account:e})=>({publicKey:t,account:this._coder.accounts.decode(this._idlAccount.name,e.data)})))}subscribe(t,e){const n=kn.get(t.toString());if(n)return n.ee;const r=new y;t=L(t);const o=this._provider.connection.onAccountChange(t,(t=>{const e=this._coder.accounts.decode(this._idlAccount.name,t.data);r.emit(\"change\",e)}),e);return kn.set(t.toString(),{ee:r,listener:o}),r}async unsubscribe(t){let e=kn.get(t.toString());e?kn&&await this._provider.connection.removeAccountChangeListener(e.listener).then((()=>{kn.delete(t.toString())})).catch(console.error):console.warn(\"Address is not subscribed\")}async createInstruction(t,e){const n=this.size;if(void 0===this._provider.wallet)throw new Error(\"This function requires the Provider interface implementor to have a 'wallet' field.\");return s.createAccount({fromPubkey:this._provider.wallet.publicKey,newAccountPubkey:t.publicKey,space:null!=e?e:n,lamports:await this._provider.connection.getMinimumBalanceForRentExemption(null!=e?e:n),programId:this._programId})}async associated(...t){const e=await this.associatedAddress(...t);return await this.fetch(e)}async associatedAddress(...t){return await sn(this._programId,...t)}async getAccountInfo(t,e){return await this._provider.connection.getAccountInfo(L(t),e)}}const kn=new Map,xn=\"Program log: \".length,Mn=\"Program data: \".length;class Pn{constructor(t,e,n){this._programId=t,this._provider=e,this._eventParser=new Ln(t,n),this._eventCallbacks=new Map,this._eventListeners=new Map,this._listenerIdCount=0}addEventListener(t,e){var n;let r=this._listenerIdCount;return this._listenerIdCount+=1,t in this._eventCallbacks||this._eventListeners.set(t,[]),this._eventListeners.set(t,(null!==(n=this._eventListeners.get(t))&&void 0!==n?n:[]).concat(r)),this._eventCallbacks.set(r,[t,e]),void 0!==this._onLogsSubscriptionId||(this._onLogsSubscriptionId=this._provider.connection.onLogs(this._programId,((t,e)=>{if(!t.err)for(const n of this._eventParser.parseLogs(t.logs)){const r=this._eventListeners.get(n.name);r&&r.forEach((r=>{const o=this._eventCallbacks.get(r);if(o){const[,r]=o;r(n.data,e.slot,t.signature)}}))}}))),r}async removeEventListener(t){const e=this._eventCallbacks.get(t);if(!e)throw new Error(`Event listener ${t} doesn't exist!`);const[n]=e;let r=this._eventListeners.get(n);if(!r)throw new Error(`Event listeners don't exist for ${n}!`);this._eventCallbacks.delete(t),r=r.filter((e=>e!==t)),0===r.length&&this._eventListeners.delete(n),0==this._eventCallbacks.size&&(g.ok(0===this._eventListeners.size),void 0!==this._onLogsSubscriptionId&&(await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId),this._onLogsSubscriptionId=void 0))}}class Ln{constructor(t,e){this.coder=e,this.programId=t}*parseLogs(t){const e=new Cn(t),n=new Tn;let r=e.next();for(;null!==r;){let[t,o,i]=this.handleLog(n,r);t&&(yield t),o&&n.push(o),i&&n.pop(),r=e.next()}}handleLog(t,e){return t.stack.length>0&&t.program()===this.programId.toString()?this.handleProgramLog(e):[null,...this.handleSystemLog(e)]}handleProgramLog(t){if(t.startsWith(\"Program log: \")||t.startsWith(\"Program data: \")){const e=t.startsWith(\"Program log: \")?t.slice(xn):t.slice(Mn);return[this.coder.events.decode(e),null,!1]}return[null,...this.handleSystemLog(t)]}handleSystemLog(t){const e=t.split(\":\")[0];return null!==e.match(/^Program (.*) success/g)?[null,!0]:e.startsWith(`Program ${this.programId.toString()} invoke`)?[this.programId.toString(),!1]:e.includes(\"invoke\")?[\"cpi\",!1]:[null,!1]}}class Tn{constructor(){this.stack=[]}program(){return g.ok(this.stack.length>0),this.stack[this.stack.length-1]}push(t){this.stack.push(t)}pop(){g.ok(this.stack.length>0),this.stack.pop()}}class Cn{constructor(t){this.logs=t}next(){if(0===this.logs.length)return null;let t=this.logs[0];return this.logs=this.logs.slice(1),t}}const zn=new e(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\");function Bn(){return new Re(On)}const On={version:\"0.1.0\",name:\"spl_token\",instructions:[{name:\"initializeMint\",accounts:[{name:\"mint\",isMut:!0,isSigner:!1},{name:\"rent\",isMut:!1,isSigner:!1}],args:[{name:\"decimals\",type:\"u8\"},{name:\"mintAuthority\",type:\"publicKey\"},{name:\"freezeAuthority\",type:{coption:\"publicKey\"}}]},{name:\"initializeAccount\",accounts:[{name:\"account\",isMut:!0,isSigner:!1},{name:\"mint\",isMut:!1,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!1},{name:\"rent\",isMut:!1,isSigner:!1}],args:[]},{name:\"initializeMultisig\",accounts:[{name:\"account\",isMut:!0,isSigner:!1},{name:\"rent\",isMut:!1,isSigner:!1}],args:[{name:\"m\",type:\"u8\"}]},{name:\"transfer\",accounts:[{name:\"source\",isMut:!0,isSigner:!1},{name:\"destination\",isMut:!0,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!0}],args:[{name:\"amount\",type:\"u64\"}]},{name:\"approve\",accounts:[{name:\"source\",isMut:!0,isSigner:!1},{name:\"delegate\",isMut:!1,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!0}],args:[{name:\"amount\",type:\"u64\"}]},{name:\"revoke\",accounts:[{name:\"source\",isMut:!0,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!0}],args:[]},{name:\"setAuthority\",accounts:[{name:\"mint\",isMut:!0,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!0}],args:[{name:\"authorityType\",type:\"u8\"},{name:\"newAuthority\",type:{coption:\"publicKey\"}}]},{name:\"mintTo\",accounts:[{name:\"mint\",isMut:!0,isSigner:!1},{name:\"to\",isMut:!0,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!0}],args:[{name:\"amount\",type:\"u64\"}]},{name:\"burn\",accounts:[{name:\"source\",isMut:!0,isSigner:!1},{name:\"mint\",isMut:!0,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!0}],args:[{name:\"amount\",type:\"u64\"}]},{name:\"closeAccount\",accounts:[{name:\"account\",isMut:!0,isSigner:!1},{name:\"destination\",isMut:!0,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!1}],args:[]},{name:\"freezeAccount\",accounts:[{name:\"account\",isMut:!0,isSigner:!1},{name:\"mint\",isMut:!1,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!0}],args:[]},{name:\"thawAccount\",accounts:[{name:\"account\",isMut:!0,isSigner:!1},{name:\"mint\",isMut:!1,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!0}],args:[]},{name:\"transferChecked\",accounts:[{name:\"source\",isMut:!0,isSigner:!1},{name:\"mint\",isMut:!1,isSigner:!1},{name:\"destination\",isMut:!0,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!0}],args:[{name:\"amount\",type:\"u64\"},{name:\"decimals\",type:\"u8\"}]},{name:\"approveChecked\",accounts:[{name:\"source\",isMut:!0,isSigner:!1},{name:\"mint\",isMut:!1,isSigner:!1},{name:\"delegate\",isMut:!1,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!0}],args:[{name:\"amount\",type:\"u64\"},{name:\"decimals\",type:\"u8\"}]},{name:\"mintToChecked\",accounts:[{name:\"mint\",isMut:!0,isSigner:!1},{name:\"to\",isMut:!0,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!0}],args:[{name:\"amount\",type:\"u64\"},{name:\"decimals\",type:\"u8\"}]},{name:\"burnChecked\",accounts:[{name:\"source\",isMut:!0,isSigner:!1},{name:\"mint\",isMut:!0,isSigner:!1},{name:\"authority\",isMut:!1,isSigner:!0}],args:[{name:\"amount\",type:\"u64\"},{name:\"decimals\",type:\"u8\"}]},{name:\"initializeAccount2\",accounts:[{name:\"account\",isMut:!0,isSigner:!1},{name:\"mint\",isMut:!1,isSigner:!1},{name:\"rent\",isMut:!1,isSigner:!1}],args:[{name:\"authority\",type:\"publicKey\"}]},{name:\"syncNative\",accounts:[{name:\"account\",isMut:!0,isSigner:!1}],args:[]},{name:\"initializeAccount3\",accounts:[{name:\"account\",isMut:!0,isSigner:!1},{name:\"mint\",isMut:!1,isSigner:!1}],args:[{name:\"authority\",type:\"publicKey\"}]},{name:\"initializeMultisig2\",accounts:[{name:\"account\",isMut:!0,isSigner:!1}],args:[{name:\"m\",type:\"u8\"}]},{name:\"initializeMint2\",accounts:[{name:\"mint\",isMut:!0,isSigner:!1}],args:[{name:\"decimals\",type:\"u8\"},{name:\"mintAuthority\",type:\"publicKey\"},{name:\"freezeAuthority\",type:{coption:\"publicKey\"}}]}],accounts:[{name:\"mint\",type:{kind:\"struct\",fields:[{name:\"mintAuthority\",type:{coption:\"publicKey\"}},{name:\"supply\",type:\"u64\"},{name:\"decimals\",type:\"u8\"},{name:\"isInitialized\",type:\"bool\"},{name:\"freezeAuthority\",type:{coption:\"publicKey\"}}]}},{name:\"token\",type:{kind:\"struct\",fields:[{name:\"mint\",type:\"publicKey\"},{name:\"authority\",type:\"publicKey\"},{name:\"amount\",type:\"u64\"},{name:\"delegate\",type:{coption:\"publicKey\"}},{name:\"state\",type:\"u8\"},{name:\"isNative\",type:{coption:\"u64\"}},{name:\"delegatedAmount\",type:\"u64\"},{name:\"closeAuthority\",type:{coption:\"publicKey\"}}]}}]};class Dn{constructor(t,e,n,r,o,i,s){this._accounts=e,this._provider=n,this._programId=r,this._idlIx=o,this._customResolver=s,this._args=t,this._accountStore=new Nn(n,i)}args(t){this._args=t}async resolve(){for(await this.resolveConst(this._idlIx.accounts);await this.resolvePdas(this._idlIx.accounts)+await this.resolveRelations(this._idlIx.accounts)>0;);this._customResolver&&(this._accounts=await this._customResolver({args:this._args,accounts:this._accounts,provider:this._provider,programId:this._programId,idlIx:this._idlIx}))}get(t){const e=t.reduce(((t,e)=>t&&t[e]),this._accounts);if(e&&e.toBase58)return e}set(t,e){let n=this._accounts;t.forEach(((r,o)=>{o==t.length-1&&(n[r]=e),n[r]=n[r]||{},n=n[r]}))}async resolveConst(t,e=[]){for(let n=0;n<t.length;n+=1){const r=t[n],o=r.accounts;o&&await this.resolveConst(o,[...e,h(r.name)]);const i=r,s=h(r.name);if(i.isSigner&&!this.get([...e,s])){if(void 0===this._provider.wallet)throw new Error(\"This function requires the Provider interface implementor to have a 'wallet' field.\");this.set([...e,s],this._provider.wallet.publicKey)}Reflect.has(Dn.CONST_ACCOUNTS,s)&&!this.get([...e,s])&&this.set([...e,s],Dn.CONST_ACCOUNTS[s])}}async resolvePdas(t,e=[]){let n=0;for(let r=0;r<t.length;r+=1){const o=t[r],i=o.accounts;i&&(n+=await this.resolvePdas(i,[...e,h(o.name)]));const s=o,a=h(o.name);s.pda&&s.pda.seeds.length>0&&!this.get([...e,a])&&(await this.autoPopulatePda(s,e),n+=1)}return n}async resolveRelations(t,e=[]){let n=0;for(let r=0;r<t.length;r+=1){const o=t[r],i=o.accounts;i&&(n+=await this.resolveRelations(i,[...e,h(o.name)]));const s=o.relations||[],a=h(o.name),c=[...e,a],u=this.get(c);if(u){const t=s.filter((t=>!this.get([...e,h(t)])));if(n+=t.length,t.length>0){const n=await this._accountStore.fetchAccount(u);await Promise.all(t.map((async t=>{const r=h(t);return this.set([...e,r],n[r]),n[r]})))}}}return n}async autoPopulatePda(t,n=[]){if(!t.pda||!t.pda.seeds)throw new Error(\"Must have seeds\");const r=await Promise.all(t.pda.seeds.map((t=>this.toBuffer(t)))),o=await this.parseProgramId(t),[i]=await e.findProgramAddress(r,o);this.set([...n,h(t.name)],i)}async parseProgramId(t){var n;if(!(null===(n=t.pda)||void 0===n?void 0:n.programId))return this._programId;switch(t.pda.programId.kind){case\"const\":return new e(this.toBufferConst(t.pda.programId.value));case\"arg\":return this.argValue(t.pda.programId);case\"account\":return await this.accountValue(t.pda.programId);default:throw new Error(`Unexpected program seed kind: ${t.pda.programId.kind}`)}}async toBuffer(t){switch(t.kind){case\"const\":return this.toBufferConst(t);case\"arg\":return await this.toBufferArg(t);case\"account\":return await this.toBufferAccount(t);default:throw new Error(`Unexpected seed kind: ${t.kind}`)}}toBufferConst(t){return this.toBufferValue(t.type,t.value)}async toBufferArg(t){const e=this.argValue(t);return this.toBufferValue(t.type,e)}argValue(t){const e=h(t.path.split(\".\")[0]),n=this._idlIx.args.findIndex((t=>t.name===e));if(-1===n)throw new Error(`Unable to find argument for seed: ${e}`);return this._args[n]}async toBufferAccount(t){const e=await this.accountValue(t);return this.toBufferValue(t.type,e)}async accountValue(t){const e=t.path.split(\".\"),n=e[0],r=this._accounts[h(n)];if(1===e.length)return r;const o=await this._accountStore.fetchAccount(r,t.account);return this.parseAccountValue(o,e.slice(1))}parseAccountValue(t,e){let n;for(;e.length>0;)n=t[h(e[0])],e=e.slice(1);return n}toBufferValue(t,e){switch(t){case\"u8\":return Buffer.from([e]);case\"u16\":let n=Buffer.alloc(2);return n.writeUInt16LE(e),n;case\"u32\":let r=Buffer.alloc(4);return r.writeUInt32LE(e),r;case\"u64\":let o=Buffer.alloc(8);return o.writeBigUInt64LE(BigInt(e)),o;case\"string\":return Buffer.from(b(e));case\"publicKey\":return e.toBuffer();default:if(t.array)return Buffer.from(e);throw new Error(`Unexpected seed type: ${t}`)}}}Dn.CONST_ACCOUNTS={associatedTokenProgram:un,rent:a,systemProgram:s.programId,tokenProgram:cn};class Nn{constructor(t,e){this._provider=t,this._accounts=e,this._cache=new Map}async fetchAccount(t,e){const n=t.toString();if(!this._cache.has(n))if(\"TokenAccount\"===e){const e=await this._provider.connection.getAccountInfo(t);if(null===e)throw new Error(`invalid account info for ${n}`);const r=Bn().accounts.decode(\"token\",e.data);this._cache.set(n,r)}else if(e){const r=this._accounts[h(e)].fetch(t);this._cache.set(n,r)}else{const e=await this._provider.connection.getAccountInfo(t);if(null===e)throw new Error(`invalid account info for ${n}`);const r=e.data,o=Object.values(this._accounts)[0];if(!o)throw new Error(\"No accounts for this program\");const i=o.coder.accounts.decodeAny(r);this._cache.set(n,i)}return this._cache.get(n)}}class Rn{static build(t,e,n,r,o,i,s,a,c,u){return(...d)=>new Vn(d,r,o,i,s,a,t,e,n,c,u)}}class Vn{constructor(t,e,n,r,o,i,s,a,c,u,d){this._ixFn=e,this._txFn=n,this._rpcFn=r,this._simulateFn=o,this._viewFn=i,this._accounts={},this._remainingAccounts=[],this._signers=[],this._preInstructions=[],this._postInstructions=[],this._autoResolveAccounts=!0,this._args=t,this._accountsResolver=new Dn(t,this._accounts,s,a,c,u,d)}args(t){this._args=t,this._accountsResolver.args(t)}async pubkeys(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._accounts}accounts(t){return this._autoResolveAccounts=!0,Object.assign(this._accounts,t),this}accountsStrict(t){return this._autoResolveAccounts=!1,Object.assign(this._accounts,t),this}signers(t){return this._signers=this._signers.concat(t),this}remainingAccounts(t){return this._remainingAccounts=this._remainingAccounts.concat(t),this}preInstructions(t){return this._preInstructions=this._preInstructions.concat(t),this}postInstructions(t){return this._postInstructions=this._postInstructions.concat(t),this}async rpc(t){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._rpcFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:t})}async view(t){if(this._autoResolveAccounts&&await this._accountsResolver.resolve(),!this._viewFn)throw new Error(\"Method does not support views\");return this._viewFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:t})}async simulate(t){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._simulateFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:t})}async instruction(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._ixFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}async prepare(){return{instruction:await this.instruction(),pubkeys:await this.pubkeys(),signers:await this._signers}}async transaction(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._txFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}}class Un{constructor(t,e,n,r,o){e=L(e),n||(n=lt()),this._idl=t,this._provider=n,this._programId=e,this._coder=null!=r?r:new qt(t),this._events=new Pn(this._programId,n,this._coder);const[i,s,a,c,u,d,l,p]=class{static build(t,e,n,r,o){const i={},s={},a={},c={},u={},d={},l=x(t),p=t.accounts?class{static build(t,e,n,r){var o;const i={};return null===(o=t.accounts)||void 0===o||o.forEach((o=>{const s=h(o.name);i[s]=new In(t,o,n,r,e)})),i}}.build(t,e,n,r):{},f=class{static build(t,e,n,r){if(void 0!==t.state)return new Sn(t,n,r,e)}}.build(t,e,n,r);return t.instructions.forEach((f=>{const m=bn.build(f,((t,n)=>e.instruction.encode(t,n)),n),y=_n.build(f,m),g=An.build(f,y,l,r),w=class{static build(t,e,n,r,o,i,s){return async(...a)=>{var c;const u=e(...a),[,d]=vn(t,[...a]);let l;if(void 0===r.simulate)throw new Error(\"This function requires 'Provider.simulate' to be implemented.\");try{l=await r.simulate(u,d.signers,null===(c=d.options)||void 0===c?void 0:c.commitment)}catch(t){throw At(t,n)}if(void 0===l)throw new Error(\"Unable to simulate transaction\");const h=l.logs;if(!h)throw new Error(\"Simulated logs not found\");const p=[];if(s.events){let t=new Ln(i,o);for(const e of t.parseLogs(h))p.push(e)}return{events:p,raw:h}}}}.build(f,y,l,r,e,n,t),v=class{static build(t,e,n,r){const o=e.accounts.find((t=>t.isMut)),i=!!e.returns;if(!o&&i)return async(...o)=>{var i,s;let a=await n(...o);const c=`Program return: ${t} `;let u=a.raw.find((t=>t.startsWith(c)));if(!u)throw new Error(\"View expected return log\");let d=E(u.slice(c.length)),l=e.returns;if(!l)throw new Error(\"View expected return type\");return Tt.fieldLayout({type:l},Array.from([...null!==(i=r.accounts)&&void 0!==i?i:[],...null!==(s=r.types)&&void 0!==s?s:[]])).decode(d)}}}.build(n,f,w,t),b=Rn.build(r,n,f,m,y,g,w,v,p,o&&o(f)),A=h(f.name);s[A]=m,a[A]=y,i[A]=g,c[A]=w,u[A]=b,v&&(d[A]=v)})),[i,s,a,p,c,u,f,d]}}.build(t,this._coder,e,n,null!=o?o:()=>{});this.rpc=i,this.instruction=s,this.transaction=a,this.account=c,this.simulate=u,this.methods=d,this.state=l,this.views=p}get programId(){return this._programId}get idl(){return this._idl}get coder(){return this._coder}get provider(){return this._provider}static async at(t,e){const n=L(t),r=await Un.fetchIdl(n,e);if(!r)throw new Error(`IDL not found for program: ${t.toString()}`);return new Un(r,n,e)}static async fetchIdl(t,n){n=null!=n?n:lt();const r=L(t),o=await async function(t){const n=(await e.findProgramAddress([],t))[0];return await e.createWithSeed(n,\"anchor:idl\",t)}(r),i=await n.connection.getAccountInfo(o);if(!i)return null;let s=(a=i.data.slice(8),wn.decode(a));var a;const c=m(s.data);return JSON.parse(v(c))}addEventListener(t,e){return this._events.addEventListener(t,e)}async removeEventListener(t){return await this._events.removeEventListener(t)}}class jn{constructor(t){}encode(t,e){if(\"create\"===h(t))return Buffer.alloc(0);throw new Error(`Invalid instruction: ${t}`)}encodeState(t,e){throw new Error(\"SPL associated token does not have state\")}}class $n{constructor(t){}encode(t,e){throw new Error(\"SPL associated token does not have state\")}decode(t){throw new Error(\"SPL associated token does not have state\")}}class Kn{constructor(t){this.idl=t}async encode(t,e){throw new Error(`Invalid account name: ${t}`)}decode(t,e){return this.decodeUnchecked(t,e)}decodeUnchecked(t,e){throw new Error(`Invalid account name: ${t}`)}memcmp(t,e){throw new Error(`Invalid account name: ${t}`)}size(t){var e;return null!==(e=Ot(this.idl,t))&&void 0!==e?e:0}}class qn{constructor(t){}decode(t){throw new Error(\"SPL associated token program does not have events\")}}class Fn{constructor(t){}encode(t,e){throw new Error(\"SPL associated token does not have user-defined types\")}decode(t,e){throw new Error(\"SPL associated token does not have user-defined types\")}}class Wn{constructor(t){this.instruction=new jn(t),this.accounts=new Kn(t),this.events=new qn(t),this.state=new $n(t),this.types=new Fn(t)}}const Gn=new e(\"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\");function Hn(t){return new Un(Jn,Gn,t,new Wn(Jn))}const Jn={version:\"0.1.0\",name:\"spl_associated_token\",instructions:[{name:\"create\",accounts:[{name:\"authority\",isMut:!0,isSigner:!0},{name:\"associatedAccount\",isMut:!0,isSigner:!1},{name:\"owner\",isMut:!1,isSigner:!1},{name:\"mint\",isMut:!1,isSigner:!1},{name:\"systemProgram\",isMut:!1,isSigner:!1},{name:\"tokenProgram\",isMut:!1,isSigner:!1},{name:\"rent\",isMut:!1,isSigner:!1}],args:[]}]};class Zn{static token(t){return function(t){return new Un(On,zn,t,Bn())}(t)}static associatedToken(t){return Hn(t)}}const Xn=new e(\"11111111111111111111111111111111\");function Qn(t){return new Un(Yn,Xn,t,new Ye(Yn))}const Yn={version:\"0.1.0\",name:\"system_program\",instructions:[{name:\"createAccount\",accounts:[{name:\"from\",isMut:!0,isSigner:!0},{name:\"to\",isMut:!0,isSigner:!0}],args:[{name:\"lamports\",type:\"u64\"},{name:\"space\",type:\"u64\"},{name:\"owner\",type:\"publicKey\"}]},{name:\"assign\",accounts:[{name:\"pubkey\",isMut:!0,isSigner:!0}],args:[{name:\"owner\",type:\"publicKey\"}]},{name:\"transfer\",accounts:[{name:\"from\",isMut:!0,isSigner:!0},{name:\"to\",isMut:!0,isSigner:!1}],args:[{name:\"lamports\",type:\"u64\"}]},{name:\"createAccountWithSeed\",accounts:[{name:\"from\",isMut:!0,isSigner:!0},{name:\"to\",isMut:!0,isSigner:!1},{name:\"base\",isMut:!1,isSigner:!0}],args:[{name:\"base\",type:\"publicKey\"},{name:\"seed\",type:\"string\"},{name:\"lamports\",type:\"u64\"},{name:\"space\",type:\"u64\"},{name:\"owner\",type:\"publicKey\"}]},{name:\"advanceNonceAccount\",accounts:[{name:\"nonce\",isMut:!0,isSigner:!1},{name:\"recentBlockhashes\",isMut:!1,isSigner:!1},{name:\"authorized\",isMut:!1,isSigner:!0}],args:[{name:\"authorized\",type:\"publicKey\"}]},{name:\"withdrawNonceAccount\",accounts:[{name:\"nonce\",isMut:!0,isSigner:!1},{name:\"to\",isMut:!0,isSigner:!1},{name:\"recentBlockhashes\",isMut:!1,isSigner:!1},{name:\"rent\",isMut:!1,isSigner:!1},{name:\"authorized\",isMut:!1,isSigner:!0}],args:[{name:\"lamports\",type:\"u64\"}]},{name:\"initializeNonceAccount\",accounts:[{name:\"nonce\",isMut:!0,isSigner:!0},{name:\"recentBlockhashes\",isMut:!1,isSigner:!1},{name:\"rent\",isMut:!1,isSigner:!1}],args:[{name:\"authorized\",type:\"publicKey\"}]},{name:\"authorizeNonceAccount\",accounts:[{name:\"nonce\",isMut:!0,isSigner:!1},{name:\"authorized\",isMut:!1,isSigner:!0}],args:[{name:\"authorized\",type:\"publicKey\"}]},{name:\"allocate\",accounts:[{name:\"pubkey\",isMut:!0,isSigner:!0}],args:[{name:\"space\",type:\"u64\"}]},{name:\"allocateWithSeed\",accounts:[{name:\"account\",isMut:!0,isSigner:!1},{name:\"base\",isMut:!1,isSigner:!0}],args:[{name:\"base\",type:\"publicKey\"},{name:\"seed\",type:\"string\"},{name:\"space\",type:\"u64\"},{name:\"owner\",type:\"publicKey\"}]},{name:\"assignWithSeed\",accounts:[{name:\"account\",isMut:!0,isSigner:!1},{name:\"base\",isMut:!1,isSigner:!0}],args:[{name:\"base\",type:\"publicKey\"},{name:\"seed\",type:\"string\"},{name:\"owner\",type:\"publicKey\"}]},{name:\"transferWithSeed\",accounts:[{name:\"from\",isMut:!0,isSigner:!1},{name:\"base\",isMut:!1,isSigner:!0},{name:\"to\",isMut:!0,isSigner:!1}],args:[{name:\"lamports\",type:\"u64\"},{name:\"seed\",type:\"string\"},{name:\"owner\",type:\"publicKey\"}]}],accounts:[{name:\"nonce\",type:{kind:\"struct\",fields:[{name:\"version\",type:\"u32\"},{name:\"state\",type:\"u32\"},{name:\"authorizedPubkey\",type:\"publicKey\"},{name:\"nonce\",type:\"publicKey\"},{name:\"feeCalculator\",type:{defined:\"FeeCalculator\"}}]}}],types:[{name:\"FeeCalculator\",type:{kind:\"struct\",fields:[{name:\"lamportsPerSignature\",type:\"u64\"}]}}]};class tr{static system(t){return Qn(t)}}export{Nt as ACCOUNT_DISCRIMINATOR_SIZE,In as AccountClient,vt as AnchorError,st as AnchorProvider,Rt as BorshAccountsCoder,qt as BorshCoder,Vt as BorshEventCoder,Ct as BorshInstructionCoder,jt as BorshStateCoder,Pn as EventManager,Ln as EventParser,gt as IdlError,_t as LangErrorCode,St as LangErrorMessage,Rn as MethodsBuilderFactory,tr as Native,Un as Program,bt as ProgramError,wt as ProgramErrorStack,Zn as Spl,Re as SplTokenCoder,Sn as StateClient,Ye as SystemCoder,Ut as eventDiscriminator,lt as getProvider,x as parseIdlErrors,dt as setProvider,vn as splitArgsAndCtx,$t as stateDiscriminator,M as toInstruction,L as translateAddress,At as translateError,gn as utils,P as validateAccounts};\n//# sourceMappingURL=index.js.map\n","codeHighlights":[{"start":{"line":3,"column":7},"end":{"line":3,"column":7}}]}]},{"message":"Node builtin polyfill \"assert\" is not installed, but auto install is disabled.","codeFrames":[{"filePath":"/Users/nprince/source/helium/packages/anchor/ts/packages/src/utils/bytes/hex.ts","codeHighlights":[{"message":"used here","start":{"line":3,"column":7},"end":{"line":3,"column":7}}]}],"documentationURL":"https://parceljs.org/features/node-emulation/#polyfilling-%26-excluding-builtin-node-modules","hints":["Install the \"assert\" package with your package manager, and run Parcel again."],"origin":"@parcel/resolver-default"}]}
